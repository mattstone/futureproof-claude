<!DOCTYPE html>
<html>
<head>
    <title>Grid-Based Donkey Kong Level Extractor</title>
    <style>
        body { 
            margin: 0; 
            padding: 20px; 
            font-family: 'Courier New', monospace; 
            background: #111; 
            color: #0f0; 
        }
        .container { max-width: 1600px; margin: 0 auto; }
        .controls { 
            background: #222; 
            padding: 20px; 
            border-radius: 8px; 
            margin-bottom: 20px;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 15px;
        }
        .analysis-area {
            display: grid;
            grid-template-columns: auto 500px;
            gap: 20px;
        }
        .canvas-container {
            position: relative;
            border: 2px solid #0f0;
        }
        #levelCanvas {
            background: #000;
            cursor: crosshair;
        }
        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            opacity: 0.3;
        }
        .output {
            background: #000;
            border: 2px solid #0f0;
            padding: 15px;
            border-radius: 5px;
            height: 800px;
            overflow-y: auto;
            font-size: 10px;
            line-height: 1.3;
        }
        button {
            background: #0f0;
            color: #000;
            border: none;
            padding: 8px 12px;
            margin: 2px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            font-size: 10px;
        }
        button:hover { background: #0a0; }
        select, input {
            background: #222;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 4px;
            font-family: 'Courier New', monospace;
            font-size: 10px;
        }
        .color-picker {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            margin: 10px 0;
        }
        .color-swatch {
            width: 20px;
            height: 20px;
            border: 2px solid #333;
            cursor: pointer;
        }
        .color-swatch.active {
            border-color: #0f0;
        }
        .element-info {
            background: #003300;
            padding: 8px;
            border-radius: 4px;
            margin: 5px 0;
        }
        .json-output {
            background: #002200;
            padding: 10px;
            border-radius: 4px;
            font-size: 9px;
            white-space: pre-wrap;
            max-height: 300px;
            overflow-y: auto;
        }
        .grid-controls {
            display: flex;
            gap: 5px;
            align-items: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🎮 Grid-Based Donkey Kong Level Extractor</h1>
        <p>Systematic extraction using Grok's grid-based methodology</p>

        <div class="controls">
            <div>
                <input type="file" id="imageInput" accept="image/*">
                <select id="levelSelect">
                    <option value="0">25M (Top Left)</option>
                    <option value="1">50M Original (Top 2nd)</option>
                    <option value="2">75M (Top 3rd)</option>
                    <option value="3">100M (Top Right)</option>
                    <option value="4">Level 5 (Middle Left)</option>
                    <option value="5">Level 6 (Middle 2nd)</option>
                    <option value="6">Level 7 (Middle 3rd)</option>
                    <option value="7">Level 8 (Middle Right)</option>
                    <option value="8">Level 9 (Bottom Left)</option>
                    <option value="9">Level 10 (Bottom 2nd)</option>
                    <option value="10">Level 11 (Bottom 3rd)</option>
                    <option value="11">Level 12 (Bottom Right)</option>
                </select>
                <button onclick="loadLevel()">📋 Load Level</button>
            </div>
            
            <div class="grid-controls">
                <label>Grid:</label>
                <input type="number" id="gridWidth" value="28" min="10" max="50"> x
                <input type="number" id="gridHeight" value="32" min="10" max="50">
                <button onclick="updateGrid()">🔧 Update Grid</button>
                <button onclick="toggleGrid()">👁️ Toggle Grid</button>
            </div>
            
            <div>
                <select id="elementType">
                    <option value="smart_line">✨ Smart Line (Auto-segment girders)</option>
                    <option value="girder_long">🏗️ Girder (Long - 12px)</option>
                    <option value="girder_short">🏗️ Girder (Short - 8px)</option>
                    <option value="ladder">🪜 Ladder</option>
                    <option value="barrel">🛢️ Barrel</option>
                    <option value="conveyor">🔄 Conveyor</option>
                    <option value="elevator">📶 Elevator</option>
                    <option value="rivet">🔩 Rivet</option>
                    <option value="spring">🌀 Spring</option>
                    <option value="fireball">🔥 Fireball</option>
                    <option value="donkey_kong">🦍 Donkey Kong</option>
                    <option value="mario">👨 Mario</option>
                    <option value="pauline">👩 Pauline</option>
                    <option value="hammer">🔨 Hammer</option>
                    <option value="bonus">⭐ Bonus</option>
                </select>
                <button onclick="toggleEditMode()" id="editModeBtn">✏️ Edit Mode</button>
                <button onclick="clearLevel()">🗑️ Clear</button>
                <button onclick="generateJSON()">📄 Generate JSON</button>
            </div>
        </div>

        <div class="analysis-area">
            <div class="canvas-container">
                <canvas id="levelCanvas" width="448" height="512"></canvas>
                <canvas id="gridOverlay" class="grid-overlay" width="448" height="512"></canvas>
            </div>
            
            <div class="output">
                <h3>🎯 Level Analysis</h3>
                
                <div class="element-info">
                    <strong>Current Element:</strong> <span id="currentElement">Girder/Platform</span><br>
                    <strong>Grid Position:</strong> <span id="gridPosition">Click on canvas</span><br>
                    <strong>Pixel Position:</strong> <span id="pixelPosition">--</span>
                </div>
                
                <div class="element-info">
                    <strong>🎯 Instructions:</strong><br>
                    <strong>Normal Mode:</strong><br>
                    1. Load levels.png → Select level<br>
                    2. Choose element type<br>
                    3. <strong>Girders:</strong> Click start → click end<br>
                    4. <strong>Others:</strong> Single click to place<br><br>
                    <strong>Edit Mode:</strong><br>
                    1. Click "✏️ Edit Mode" to toggle<br>
                    2. Click girder to select it<br>
                    3. Click and drag start/end points<br>
                    4. ESC to cancel/deselect<br><br>
                    <strong>Status:</strong> <span id="instructionStatus">Ready</span>
                </div>
                
                <h4>🎨 Color Palettes (Click to select):</h4>
                <div class="color-picker" id="colorPicker">
                    <!-- Colors will be populated dynamically -->
                </div>
                <div>Selected Color: <span id="selectedColor">#FF6B47</span></div>
                
                <h4>📊 Extracted Elements (<span id="elementCount">0</span>):</h4>
                <div id="elementsList"></div>
                
                <h4>💻 JSON Output:</h4>
                <div class="json-output" id="jsonOutput">
                    Click "Generate JSON" to see structured output...
                </div>
            </div>
        </div>
    </div>

    <script>
        let sourceImage = null;
        let canvas = document.getElementById('levelCanvas');
        let ctx = canvas.getContext('2d');
        let gridCanvas = document.getElementById('gridOverlay');
        let gridCtx = gridCanvas.getContext('2d');
        
        let currentLevel = {
            label: "25M",
            grid_dimensions: { width: 28, height: 32 },
            elements: [],
            palettes_used: [],
            estimated_resolution: { width: 224, height: 256 }
        };
        
        let selectedColor = '#FF6B47';
        let showGrid = true;
        let gridWidth = 28;
        let gridHeight = 32;
        let editMode = false;
        let selectedElement = null;
        let dragMode = null; // 'start', 'end', or null
        
        // Authentic Donkey Kong color palettes (corrected)
        const donkeyKongPalettes = {
            "Girder Colors (Authentic)": ["#FF6B89", "#FF5577", "#E04466", "#CC3355"], // More pinkish-red girders
            "Platform Colors": ["#FF4D6D", "#FF6B47", "#E6336B", "#D62D20"], // Various platform shades  
            "Ladder Colors": ["#DAA520", "#B8860B", "#CD853F", "#DEB887"], // Golden ladder colors
            "Character Colors": ["#FF0000", "#0000FF", "#FFD700", "#FFFFFF"],
            "Structural Elements": ["#8B4513", "#A0522D", "#CD853F", "#D2B48C"], // Brown supports
            "Background Colors": ["#000000", "#1a1a1a", "#333333", "#666666"]
        };

        // Initialize color picker
        function initializeColorPicker() {
            const picker = document.getElementById('colorPicker');
            Object.entries(donkeyKongPalettes).forEach(([paletteName, colors]) => {
                const paletteDiv = document.createElement('div');
                paletteDiv.innerHTML = `<strong>${paletteName}:</strong><br>`;
                
                colors.forEach(color => {
                    const swatch = document.createElement('div');
                    swatch.className = 'color-swatch';
                    swatch.style.backgroundColor = color;
                    swatch.title = color;
                    swatch.onclick = () => selectColor(color);
                    paletteDiv.appendChild(swatch);
                });
                
                picker.appendChild(paletteDiv);
            });
        }

        function selectColor(color) {
            selectedColor = color;
            document.getElementById('selectedColor').textContent = color;
            
            // Update active swatch
            document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
            document.querySelectorAll('.color-swatch').forEach(s => {
                if (s.style.backgroundColor === color || s.title === color) {
                    s.classList.add('active');
                }
            });
        }

        // Load image
        document.getElementById('imageInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    const img = new Image();
                    img.onload = function() {
                        sourceImage = img;
                        loadLevel();
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
        });

        function loadLevel() {
            if (!sourceImage) {
                document.getElementById('instructionStatus').textContent = 'ERROR: No image loaded!';
                document.getElementById('instructionStatus').style.color = '#ff0000';
                return;
            }

            const levelIndex = parseInt(document.getElementById('levelSelect').value);
            const levelNames = ["25M", "50M Original", "75M", "100M", "Level 5", "Level 6", "Level 7", "Level 8", "Level 9", "Level 10", "Level 11", "Level 12"];
            
            currentLevel.label = levelNames[levelIndex];
            
            // Calculate level boundaries (4 columns × 3 rows)
            const levelWidth = sourceImage.width / 4;
            const levelHeight = sourceImage.height / 3;
            const col = levelIndex % 4;
            const row = Math.floor(levelIndex / 4);
            
            const startX = col * levelWidth;
            const startY = row * levelHeight;
            
            // Set canvas size and draw level
            canvas.width = levelWidth * 2; // Scale up for better visibility
            canvas.height = levelHeight * 2;
            gridCanvas.width = canvas.width;
            gridCanvas.height = canvas.height;
            
            try {
                ctx.imageSmoothingEnabled = false; // Keep pixel art sharp
                ctx.drawImage(sourceImage, startX, startY, levelWidth, levelHeight, 0, 0, canvas.width, canvas.height);
                
                // Update estimated resolution
                currentLevel.estimated_resolution = {
                    width: Math.round(levelWidth),
                    height: Math.round(levelHeight)
                };
                
                updateGrid();
                clearLevel();
                
                document.getElementById('instructionStatus').textContent = `${currentLevel.label} loaded successfully`;
                document.getElementById('instructionStatus').style.color = '#0f0';
                
                console.log(`Loaded ${currentLevel.label}: ${levelWidth}x${levelHeight} (scaled to ${canvas.width}x${canvas.height})`);
            } catch (error) {
                document.getElementById('instructionStatus').textContent = `ERROR loading level: ${error.message}`;
                document.getElementById('instructionStatus').style.color = '#ff0000';
                console.error('Level loading error:', error);
            }
        }

        function updateGrid() {
            gridWidth = parseInt(document.getElementById('gridWidth').value);
            gridHeight = parseInt(document.getElementById('gridHeight').value);
            currentLevel.grid_dimensions = { width: gridWidth, height: gridHeight };
            drawGrid();
        }

        function toggleGrid() {
            showGrid = !showGrid;
            drawGrid();
        }

        function drawGrid() {
            gridCtx.clearRect(0, 0, gridCanvas.width, gridCanvas.height);
            
            if (!showGrid) return;
            
            const cellWidth = canvas.width / gridWidth;
            const cellHeight = canvas.height / gridHeight;
            
            gridCtx.strokeStyle = '#00FF00';
            gridCtx.lineWidth = 1;
            
            // Draw vertical lines
            for (let i = 0; i <= gridWidth; i++) {
                const x = i * cellWidth;
                gridCtx.beginPath();
                gridCtx.moveTo(x, 0);
                gridCtx.lineTo(x, canvas.height);
                gridCtx.stroke();
            }
            
            // Draw horizontal lines  
            for (let i = 0; i <= gridHeight; i++) {
                const y = i * cellHeight;
                gridCtx.beginPath();
                gridCtx.moveTo(0, y);
                gridCtx.lineTo(canvas.width, y);
                gridCtx.stroke();
            }
            
            // Draw grid coordinates (every 5th line)
            gridCtx.fillStyle = '#00FF00';
            gridCtx.font = '8px monospace';
            for (let i = 0; i <= gridWidth; i += 5) {
                const x = i * cellWidth;
                gridCtx.fillText(i.toString(), x + 2, 10);
            }
            for (let i = 0; i <= gridHeight; i += 5) {
                const y = i * cellHeight;
                gridCtx.fillText(i.toString(), 2, y - 2);
            }
        }

        // Canvas click handling with multi-click support for girders
        let pendingGirder = null;
        
        function toggleEditMode() {
            editMode = !editMode;
            console.log('Edit mode toggled:', editMode);
            const btn = document.getElementById('editModeBtn');
            if (editMode) {
                btn.textContent = '🎯 Normal Mode';
                btn.style.background = '#ff0';
                btn.style.color = '#000';
                document.getElementById('instructionStatus').textContent = 'EDIT MODE: Girders are ORANGE with green dots - click any girder to select it';
                document.getElementById('instructionStatus').style.color = '#ff0';
                console.log('Entering edit mode - girders available:', currentLevel.elements.filter(el => el.type.includes('girder')).length);
            } else {
                btn.textContent = '✏️ Edit Mode';
                btn.style.background = '#0f0';
                btn.style.color = '#000';
                selectedElement = null;
                dragMode = null;
                document.getElementById('instructionStatus').textContent = 'Normal Mode: Place new elements';
                document.getElementById('instructionStatus').style.color = '#0f0';
                console.log('Exiting edit mode');
            }
            redrawCanvas();
        }
        
        canvas.addEventListener('click', function(e) {
            const rect = canvas.getBoundingClientRect();
            const x = Math.round(e.clientX - rect.left);
            const y = Math.round(e.clientY - rect.top);
            
            // Convert to grid coordinates
            const cellWidth = canvas.width / gridWidth;
            const cellHeight = canvas.height / gridHeight;
            const gridX = Math.floor(x / cellWidth);
            const gridY = Math.floor((canvas.height - y) / cellHeight); // Flip Y to make (0,0) bottom-left
            
            // Convert to game coordinates (scaled to standard DK resolution)
            const gameX = Math.round((x / canvas.width) * currentLevel.estimated_resolution.width);
            const gameY = Math.round(((canvas.height - y) / canvas.height) * currentLevel.estimated_resolution.height);
            
            document.getElementById('gridPosition').textContent = `(${gridX}, ${gridY})`;
            document.getElementById('pixelPosition').textContent = `Game: (${gameX}, ${gameY}) | Canvas: (${x}, ${y})`;
            
            if (editMode) {
                // Edit mode: select girders or move their points
                handleEditModeClick(x, y, gridX, gridY, gameX, gameY);
            } else {
                // Normal mode: place new elements
                const elementType = document.getElementById('elementType').value;
                
                // Handle girders with start/end points
                if (elementType === 'girder_long' || elementType === 'girder_short' || elementType === 'smart_line') {
                    if (pendingGirder === null) {
                        pendingGirder = {
                            startGridX: gridX, startGridY: gridY,
                            startGameX: gameX, startGameY: gameY,
                            startCanvasX: x, startCanvasY: y
                        };
                        
                        // Draw temporary marker
                        drawTempMarker(x, y, '#ff0000');
                        document.getElementById('gridPosition').textContent += ' (Click end point)';
                        document.getElementById('instructionStatus').textContent = 'Girder started - click end point';
                    } else {
                        // Complete the girder or smart line
                        if (elementType === 'smart_line') {
                            addSmartLine(pendingGirder, {
                                endGridX: gridX, endGridY: gridY,
                                endGameX: gameX, endGameY: gameY,
                                endCanvasX: x, endCanvasY: y
                            });
                        } else {
                            addGirder(pendingGirder, {
                                endGridX: gridX, endGridY: gridY,
                                endGameX: gameX, endGameY: gameY,
                                endCanvasX: x, endCanvasY: y
                            });
                        }
                        pendingGirder = null;
                        redrawCanvas();
                        document.getElementById('instructionStatus').textContent = elementType === 'smart_line' ? 'Smart line segmented!' : 'Girder completed';
                    }
                } else {
                    // Single-click elements
                    addElement(gridX, gridY, gameX, gameY);
                    document.getElementById('instructionStatus').textContent = `${elementType} placed`;
                }
            }
        });
        
        function handleEditModeClick(canvasX, canvasY, gridX, gridY, gameX, gameY) {
            console.log('Edit mode click at:', canvasX, canvasY);
            
            if (selectedElement && dragMode) {
                // Complete the drag operation
                console.log('Completing drag operation:', dragMode);
                if (dragMode === 'start') {
                    selectedElement.grid_position = { x: gridX, y: gridY };
                    selectedElement.game_position = { x: gameX, y: gameY };
                } else if (dragMode === 'end') {
                    selectedElement.end_grid_position = { x: gridX, y: gridY };
                    selectedElement.end_game_position = { x: gameX, y: gameY };
                    // Recalculate length
                    selectedElement.length = Math.sqrt(
                        Math.pow(selectedElement.end_game_position.x - selectedElement.game_position.x, 2) + 
                        Math.pow(selectedElement.end_game_position.y - selectedElement.game_position.y, 2)
                    );
                }
                dragMode = null;
                updateElementsList();
                redrawCanvas();
                document.getElementById('instructionStatus').textContent = 'Girder moved successfully';
                return;
            }
            
            // Find clicked girder
            const clickedGirder = findGirderAtPosition(canvasX, canvasY);
            console.log('Clicked girder found:', clickedGirder);
            
            if (clickedGirder) {
                selectedElement = clickedGirder.element;
                const clickedEnd = clickedGirder.end; // 'start' or 'end'
                dragMode = clickedEnd;
                
                console.log('Selected girder:', clickedGirder.index + 1, 'end:', clickedEnd);
                document.getElementById('instructionStatus').textContent = `Selected girder ${clickedGirder.index + 1} ${clickedEnd} point - click new position`;
                redrawCanvas(); // Redraw with selection highlight
            } else {
                // Deselect
                console.log('No girder found, deselecting');
                selectedElement = null;
                dragMode = null;
                document.getElementById('instructionStatus').textContent = 'Edit Mode: Click girders to select and move';
                redrawCanvas();
            }
        }
        
        function findGirderAtPosition(canvasX, canvasY) {
            const tolerance = 15; // Click tolerance in pixels
            console.log('Searching for girder at:', canvasX, canvasY, 'tolerance:', tolerance);
            console.log('Available elements:', currentLevel.elements.length);
            
            for (let i = currentLevel.elements.length - 1; i >= 0; i--) {
                const element = currentLevel.elements[i];
                console.log('Checking element', i, 'type:', element.type);
                
                if (element.type === 'girder_long' || element.type === 'girder_short' || element.type === 'girder') {
                    if (element.end_game_position) {
                        // Convert girder points to canvas coordinates
                        const startCanvasX = (element.game_position.x / currentLevel.estimated_resolution.width) * canvas.width;
                        const startCanvasY = canvas.height - ((element.game_position.y / currentLevel.estimated_resolution.height) * canvas.height);
                        const endCanvasX = (element.end_game_position.x / currentLevel.estimated_resolution.width) * canvas.width;
                        const endCanvasY = canvas.height - ((element.end_game_position.y / currentLevel.estimated_resolution.height) * canvas.height);
                        
                        console.log('Girder', i, 'canvas coords:', startCanvasX, startCanvasY, 'to', endCanvasX, endCanvasY);
                        
                        // Check if click is near start point
                        const startDist = Math.sqrt(Math.pow(canvasX - startCanvasX, 2) + Math.pow(canvasY - startCanvasY, 2));
                        console.log('Distance to start point:', startDist);
                        if (startDist <= tolerance) {
                            console.log('Found girder via start point');
                            return { element, end: 'start', index: i };
                        }
                        
                        // Check if click is near end point
                        const endDist = Math.sqrt(Math.pow(canvasX - endCanvasX, 2) + Math.pow(canvasY - endCanvasY, 2));
                        console.log('Distance to end point:', endDist);
                        if (endDist <= tolerance) {
                            console.log('Found girder via end point');
                            return { element, end: 'end', index: i };
                        }
                        
                        // Check if click is near the line itself
                        const lineDistSq = distanceToLineSquared(canvasX, canvasY, startCanvasX, startCanvasY, endCanvasX, endCanvasY);
                        console.log('Distance to line (squared):', lineDistSq);
                        if (lineDistSq <= tolerance * tolerance) {
                            console.log('Found girder via line');
                            // Default to moving the closest end
                            return { element, end: startDist < endDist ? 'start' : 'end', index: i };
                        }
                    } else {
                        console.log('Girder', i, 'has no end_game_position');
                    }
                }
            }
            console.log('No girder found at position');
            return null;
        }
        
        function distanceToLineSquared(px, py, x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const lengthSq = dx * dx + dy * dy;
            
            if (lengthSq === 0) return Math.pow(px - x1, 2) + Math.pow(py - y1, 2);
            
            const t = Math.max(0, Math.min(1, ((px - x1) * dx + (py - y1) * dy) / lengthSq));
            const projX = x1 + t * dx;
            const projY = y1 + t * dy;
            
            return Math.pow(px - projX, 2) + Math.pow(py - projY, 2);
        }
        
        // Handle ESC key for cancellation
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                if (editMode && (selectedElement || dragMode)) {
                    // Cancel edit mode selection/drag
                    selectedElement = null;
                    dragMode = null;
                    redrawCanvas();
                    document.getElementById('instructionStatus').textContent = 'Edit cancelled - ready to select girder';
                    document.getElementById('instructionStatus').style.color = '#ff0';
                } else if (pendingGirder) {
                    // Cancel girder creation
                    pendingGirder = null;
                    redrawCanvas();
                    document.getElementById('gridPosition').textContent = 'Girder cancelled (ESC pressed)';
                    document.getElementById('instructionStatus').textContent = 'Girder cancelled - ready for next element';
                    document.getElementById('instructionStatus').style.color = '#ff0';
                }
            }
        });
        
        // Handle element type changes - cancel pending girder
        document.getElementById('elementType').addEventListener('change', function() {
            if (pendingGirder) {
                pendingGirder = null;
                redrawCanvas();
                document.getElementById('instructionStatus').textContent = 'Girder cancelled - element type changed';
                document.getElementById('instructionStatus').style.color = '#ff0';
            }
            document.getElementById('currentElement').textContent = this.options[this.selectedIndex].text;
        });

        function addElement(gridX, gridY, gameX, gameY) {
            const elementType = document.getElementById('elementType').value;
            const elementName = document.getElementById('elementType').options[document.getElementById('elementType').selectedIndex].text;
            
            const element = {
                type: elementType,
                grid_position: { x: gridX, y: gridY },
                game_position: { x: gameX, y: gameY },
                color: selectedColor,
                timestamp: Date.now(),
                id: currentLevel.elements.length + 1
            };
            
            // Add type-specific properties
            switch(elementType) {
                case 'girder':
                    element.length = 50; // Default, can be adjusted
                    element.orientation = 'horizontal';
                    break;
                case 'ladder':
                    element.height = 30; // Default
                    break;
                case 'conveyor':
                    element.direction = 'right';
                    element.length = 40;
                    break;
                case 'elevator':
                    element.travel_height = 50;
                    break;
            }
            
            currentLevel.elements.push(element);
            updateElementsList();
            
            console.log(`Added ${elementType} at grid (${gridX}, ${gridY}) / game (${gameX}, ${gameY})`);
        }

        function updateElementsList() {
            const list = document.getElementById('elementsList');
            const count = document.getElementById('elementCount');
            
            count.textContent = currentLevel.elements.length;
            
            list.innerHTML = currentLevel.elements.map((el, i) => {
                let details = `Grid: (${el.grid_position.x}, ${el.grid_position.y})<br>Game: (${el.game_position.x}, ${el.game_position.y})`;
                
                if (el.type === 'girder' && el.end_game_position) {
                    details += `<br>End Grid: (${el.end_grid_position.x}, ${el.end_grid_position.y})<br>End Game: (${el.end_game_position.x}, ${el.end_game_position.y})<br>Length: ${Math.round(el.length)}px`;
                }
                
                if (el.height) {
                    details += `<br>Height: ${el.height}px`;
                }
                
                if (el.orientation) {
                    details += `<br>Orientation: ${el.orientation}`;
                }
                
                return `
                    <div class="element-info">
                        <strong>${i+1}. ${el.type}</strong><br>
                        ${details}<br>
                        Color: <span style="color: ${el.color}">${el.color}</span>
                        <button onclick="removeElement(${i})" style="margin-left: 5px; background: #f00;">❌</button>
                    </div>
                `;
            }).join('');
        }

        function removeElement(index) {
            currentLevel.elements.splice(index, 1);
            updateElementsList();
        }

        function clearLevel() {
            currentLevel.elements = [];
            updateElementsList();
        }

        function generateJSON() {
            const output = {
                level: currentLevel,
                extraction_metadata: {
                    extracted_at: new Date().toISOString(),
                    canvas_dimensions: { width: canvas.width, height: canvas.height },
                    grid_settings: { width: gridWidth, height: gridHeight },
                    scaling_factor: {
                        x: currentLevel.estimated_resolution.width / canvas.width,
                        y: currentLevel.estimated_resolution.height / canvas.height
                    }
                },
                javascript_code: generateJavaScriptCode()
            };
            
            document.getElementById('jsonOutput').textContent = JSON.stringify(output, null, 2);
        }

        function drawTempMarker(x, y, color) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            
            tempCtx.drawImage(canvas, 0, 0);
            
            tempCtx.fillStyle = color;
            tempCtx.beginPath();
            tempCtx.arc(x, y, 5, 0, 2 * Math.PI);
            tempCtx.fill();
            
            tempCtx.strokeStyle = '#ffffff';
            tempCtx.lineWidth = 2;
            tempCtx.stroke();
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(tempCanvas, 0, 0);
        }
        
        function redrawCanvas() {
            if (!sourceImage) return;
            
            const levelIndex = parseInt(document.getElementById('levelSelect').value);
            const levelWidth = sourceImage.width / 4;
            const levelHeight = sourceImage.height / 3;
            const col = levelIndex % 4;
            const row = Math.floor(levelIndex / 4);
            
            const startX = col * levelWidth;
            const startY = row * levelHeight;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(sourceImage, startX, startY, levelWidth, levelHeight, 0, 0, canvas.width, canvas.height);
            
            // Redraw all elements
            drawElements();
        }
        
        function drawElements() {
            currentLevel.elements.forEach((element, index) => {
                const canvasX = (element.game_position.x / currentLevel.estimated_resolution.width) * canvas.width;
                const canvasY = canvas.height - ((element.game_position.y / currentLevel.estimated_resolution.height) * canvas.height);
                
                ctx.fillStyle = element.color;
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                
                switch(element.type) {
                    case 'girder_long':
                    case 'girder_short':
                        if (element.end_game_position) {
                            const endCanvasX = (element.end_game_position.x / currentLevel.estimated_resolution.width) * canvas.width;
                            const endCanvasY = canvas.height - ((element.end_game_position.y / currentLevel.estimated_resolution.height) * canvas.height);
                            
                            // Highlight selected girder in edit mode
                            const isSelected = editMode && selectedElement === element;
                            const isEditable = editMode && !isSelected;
                            
                            ctx.beginPath();
                            ctx.moveTo(canvasX, canvasY);
                            ctx.lineTo(endCanvasX, endCanvasY);
                            
                            if (isSelected) {
                                // Selected girder: bright yellow, thicker
                                ctx.lineWidth = 8;
                                ctx.strokeStyle = '#FFFF00';
                            } else if (isEditable) {
                                // Editable girders: orange glow effect
                                ctx.lineWidth = 8;
                                ctx.strokeStyle = '#FFA500';
                                ctx.globalAlpha = 0.7;
                            } else {
                                // Normal girders
                                ctx.lineWidth = 6;
                                ctx.strokeStyle = element.color;
                                ctx.globalAlpha = 1.0;
                            }
                            
                            ctx.stroke();
                            ctx.globalAlpha = 1.0; // Reset alpha
                            
                            // Draw small endpoint indicators in edit mode
                            if (editMode) {
                                // Start point indicator
                                ctx.fillStyle = isSelected && dragMode === 'start' ? '#FF0000' : 
                                               isSelected ? '#FFFF00' : '#00FF00';
                                ctx.beginPath();
                                ctx.arc(canvasX, canvasY, isSelected ? 6 : 3, 0, 2 * Math.PI);
                                ctx.fill();
                                if (isSelected) {
                                    ctx.strokeStyle = '#000';
                                    ctx.lineWidth = 2;
                                    ctx.stroke();
                                }
                                
                                // End point indicator
                                ctx.fillStyle = isSelected && dragMode === 'end' ? '#FF0000' : 
                                               isSelected ? '#FFFF00' : '#00FF00';
                                ctx.beginPath();
                                ctx.arc(endCanvasX, endCanvasY, isSelected ? 6 : 3, 0, 2 * Math.PI);
                                ctx.fill();
                                if (isSelected) {
                                    ctx.strokeStyle = '#000';
                                    ctx.lineWidth = 2;
                                    ctx.stroke();
                                }
                            }
                            
                            // Draw girder length indicator
                            if (!isSelected || !dragMode) {
                                ctx.fillStyle = editMode ? '#FFFFFF' : element.color;
                                ctx.font = editMode ? 'bold 10px monospace' : '10px monospace';
                                const midX = (canvasX + endCanvasX) / 2;
                                const midY = (canvasY + endCanvasY) / 2;
                                
                                // Add background for better readability in edit mode
                                if (editMode) {
                                    const text = element.expected_length + 'px';
                                    const textWidth = ctx.measureText(text).width;
                                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                                    ctx.fillRect(midX - textWidth/2 - 2, midY - 12, textWidth + 4, 14);
                                    ctx.fillStyle = '#FFFFFF';
                                }
                                
                                ctx.fillText(element.expected_length + 'px', midX - 10, midY - 4);
                            }
                        }
                        break;
                    case 'girder':
                        // Legacy girder support
                        if (element.end_game_position) {
                            const endCanvasX = (element.end_game_position.x / currentLevel.estimated_resolution.width) * canvas.width;
                            const endCanvasY = canvas.height - ((element.end_game_position.y / currentLevel.estimated_resolution.height) * canvas.height);
                            
                            ctx.beginPath();
                            ctx.moveTo(canvasX, canvasY);
                            ctx.lineTo(endCanvasX, endCanvasY);
                            ctx.lineWidth = 6;
                            ctx.strokeStyle = element.color;
                            ctx.stroke();
                        }
                        break;
                    case 'ladder':
                        ctx.fillRect(canvasX - 2, canvasY - 15, 4, 30);
                        break;
                    default:
                        ctx.beginPath();
                        ctx.arc(canvasX, canvasY, 4, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.stroke();
                        break;
                }
                
                // Draw element number
                ctx.fillStyle = '#ffffff';
                ctx.font = '12px monospace';
                ctx.fillText((index + 1).toString(), canvasX + 8, canvasY - 8);
            });
        }
        
        function addGirder(start, end) {
            const elementType = document.getElementById('elementType').value;
            const expectedLength = elementType === 'girder_long' ? 12 : 8;
            
            const element = {
                type: elementType,
                girder_type: elementType === 'girder_long' ? 'long' : 'short',
                expected_length: expectedLength,
                grid_position: { x: start.startGridX, y: start.startGridY },
                game_position: { x: start.startGameX, y: start.startGameY },
                end_grid_position: { x: end.endGridX, y: end.endGridY },
                end_game_position: { x: end.endGameX, y: end.endGameY },
                color: selectedColor,
                timestamp: Date.now(),
                id: currentLevel.elements.length + 1,
                length: Math.sqrt(Math.pow(end.endGameX - start.startGameX, 2) + Math.pow(end.endGameY - start.startGameY, 2)),
                orientation: Math.abs(end.endGameX - start.startGameX) > Math.abs(end.endGameY - start.startGameY) ? 'horizontal' : 'vertical'
            };
            
            currentLevel.elements.push(element);
            updateElementsList();
            
            console.log(`Added ${expectedLength}px ${element.girder_type} girder from (${start.startGameX}, ${start.startGameY}) to (${end.endGameX}, ${end.endGameY})`);
        }
        
        function addSmartLine(start, end) {
            // Calculate total line length in game coordinates
            const totalLength = Math.sqrt(
                Math.pow(end.endGameX - start.startGameX, 2) + 
                Math.pow(end.endGameY - start.startGameY, 2)
            );
            
            console.log(`Smart line: ${totalLength.toFixed(1)}px long`);
            
            // Determine girder size based on total length
            // Assume typical Donkey Kong girder patterns:
            // - Long girders (12px) for main platforms
            // - Short girders (8px) for smaller segments
            const averageGirderLength = totalLength < 50 ? 8 : 12;
            const numGirders = Math.max(1, Math.round(totalLength / averageGirderLength));
            const actualGirderLength = totalLength / numGirders;
            
            console.log(`Creating ${numGirders} girders of ${actualGirderLength.toFixed(1)}px each`);
            
            // Calculate direction vector
            const deltaX = end.endGameX - start.startGameX;
            const deltaY = end.endGameY - start.startGameY;
            
            // Create individual girders along the line
            for (let i = 0; i < numGirders; i++) {
                const segmentStart = i / numGirders;
                const segmentEnd = (i + 1) / numGirders;
                
                const startX = Math.round(start.startGameX + deltaX * segmentStart);
                const startY = Math.round(start.startGameY + deltaY * segmentStart);
                const endX = Math.round(start.startGameX + deltaX * segmentEnd);
                const endY = Math.round(start.startGameY + deltaY * segmentEnd);
                
                // Convert back to grid coordinates for consistency
                const startGridX = Math.floor((startX / currentLevel.estimated_resolution.width) * gridWidth);
                const startGridY = Math.floor(((currentLevel.estimated_resolution.height - startY) / currentLevel.estimated_resolution.height) * gridHeight);
                const endGridX = Math.floor((endX / currentLevel.estimated_resolution.width) * gridWidth);
                const endGridY = Math.floor(((currentLevel.estimated_resolution.height - endY) / currentLevel.estimated_resolution.height) * gridHeight);
                
                const girderType = actualGirderLength > 10 ? 'girder_long' : 'girder_short';
                const expectedLength = actualGirderLength > 10 ? 12 : 8;
                
                const element = {
                    type: girderType,
                    girder_type: actualGirderLength > 10 ? 'long' : 'short',
                    expected_length: expectedLength,
                    grid_position: { x: startGridX, y: startGridY },
                    game_position: { x: startX, y: startY },
                    end_grid_position: { x: endGridX, y: endGridY },
                    end_game_position: { x: endX, y: endY },
                    color: selectedColor,
                    timestamp: Date.now(),
                    id: currentLevel.elements.length + 1,
                    length: actualGirderLength,
                    orientation: Math.abs(deltaX) > Math.abs(deltaY) ? 'horizontal' : 'vertical',
                    smart_segment: i + 1, // Track which segment this is
                    smart_total: numGirders // Track total segments in this line
                };
                
                currentLevel.elements.push(element);
                console.log(`  Segment ${i+1}/${numGirders}: (${startX}, ${startY}) to (${endX}, ${endY})`);
            }
            
            updateElementsList();
            
            document.getElementById('instructionStatus').textContent = 
                `Smart line created: ${numGirders} × ${actualGirderLength.toFixed(1)}px ${actualGirderLength > 10 ? 'long' : 'short'} girders`;
        }

        function generateJavaScriptCode() {
            let code = `// Generated from ${currentLevel.label}\n`;
            code += `// Grid: ${gridWidth}x${gridHeight}, Resolution: ${currentLevel.estimated_resolution.width}x${currentLevel.estimated_resolution.height}\n\n`;
            
            // Filter all girder types (including legacy)
            const girders = currentLevel.elements.filter(el => el.type === 'girder' || el.type === 'girder_long' || el.type === 'girder_short');
            const ladders = currentLevel.elements.filter(el => el.type === 'ladder');
            const characters = currentLevel.elements.filter(el => ['mario', 'donkey_kong', 'pauline'].includes(el.type));
            
            if (girders.length > 0) {
                code += `this.girders = [\n`;
                girders.forEach((girder, i) => {
                    const startX = girder.game_position.x;
                    const startY = girder.game_position.y;
                    const endX = girder.end_game_position ? girder.end_game_position.x : startX + 50;
                    const endY = girder.end_game_position ? girder.end_game_position.y : startY;
                    
                    let comment = '';
                    if (girder.girder_type) {
                        comment = ` // ${girder.expected_length}px ${girder.girder_type} girder`;
                    }
                    
                    code += `  { startX: ${startX}, startY: ${startY}, endX: ${endX}, endY: ${endY}, color: '${girder.color}',\n`;
                    code += `    segments: this.createGirderSegments(${startX}, ${startY}, ${endX}, ${endY}) }${i < girders.length - 1 ? ',' : ''}${comment}\n`;
                });
                code += `];\n\n`;
            }
            
            if (ladders.length > 0) {
                code += `this.ladders = [\n`;
                ladders.forEach((ladder, i) => {
                    code += `  { x: ${ladder.game_position.x}, y: ${ladder.game_position.y}, width: 16, height: ${ladder.height || 30} }${i < ladders.length - 1 ? ',' : ''}\n`;
                });
                code += `];\n\n`;
            }
            
            if (characters.length > 0) {
                code += `// Character positions\n`;
                characters.forEach(char => {
                    const varName = char.type === 'donkey_kong' ? 'donkeyKong' : char.type;
                    code += `this.${varName}.x = ${char.game_position.x};\n`;
                    code += `this.${varName}.y = ${char.game_position.y};\n`;
                });
            }
            
            return code;
        }


        // Initialize
        initializeColorPicker();
        selectColor('#FF6B47');
        drawGrid();
    </script>
</body>
</html>