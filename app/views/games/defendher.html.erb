<%= render 'shared/header' %>

<div class="defendher-container" data-controller="defendher">
  <!-- Professional Loading Screen -->
  <div id="loadingScreen" class="game-loading" data-defendher-target="loadingScreen">
    <div class="loading-content">
      <%= image_tag "arcade/defendher/Art/deflogo.jpg", class: "game-logo", alt: "DefendHer Logo" %>
      <div class="loading-spinner"></div>
      <div class="loading-text">DEFENDHER</div>
      <div class="loading-subtitle">Initializing Planet Defense System...</div>
    </div>
  </div>

  <h1 class="game-title">🚀 DefendHer</h1>
  <p class="game-subtitle">Save Humanity from Alien Invasion!</p>
  
  <div id="gameContainer" class="game-container">
    <canvas id="gameCanvas" 
            class="game-canvas" 
            width="800" 
            height="600" 
            tabindex="0"
            data-defendher-target="canvas"
            data-action="click->defendher#focusGame"></canvas>
    <div id="gameInstructions" class="game-instructions">
      🚀 Click on game area to focus • Arrow Keys: Move • Space: Fire • Shift: Bomb
    </div>
    
    <!-- Game UI Overlay -->
    <div id="ui">
      <div class="ui-panel score-panel">
        <div>SCORE: <span id="score">0</span></div>
      </div>
      <div class="ui-panel lives-panel">
        <div>LIVES: <span id="lives">3</span></div>
      </div>
      <div class="ui-panel wave-panel">
        <div>WAVE: <span id="wave">1</span></div>
      </div>
      <div class="ui-panel humanoids-panel">
        <div>WOMEN: <span id="humanoids">10</span></div>
      </div>
      <div class="ui-panel debug-panel" id="debug" style="display: none;">
        <div>DEBUG INFO:</div>
        <div>Game loading...</div>
      </div>
      
      <div id="startScreen" class="start-screen">
        <h2>DEFENDHER</h2>
        <p>Save womankind from alien invasion!</p>
        <p>◄ ► Move • ▲ ▼ Up/Down • SPACE Fire • SHIFT Bomb</p>
        <p>Rescue falling women • Destroy alien invaders</p>
        <p>Press SPACE to start</p>
      </div>
      
      <div id="gameOverScreen" class="game-over" style="display: none;">
        <h2>GAME OVER</h2>
        <p>Your Score: <span id="finalScore">0</span></p>
        <p>Women Saved: <span id="humansRescued">0</span></p>
        <p>Press SPACE to restart</p>
      </div>
    </div>
  </div>
  
  <div id="gameControls" class="game-controls">
    <div id="gameInfo" class="game-info">
      <span class="score-item score-green">SCORE: <span id="scoreDisplay" data-defendher-target="score">000000</span></span>
      <span class="score-item score-cyan">LIVES: <span id="livesDisplay" data-defendher-target="lives">3</span></span>
      <span class="score-item score-yellow">BOMBS: <span id="bombsDisplay" data-defendher-target="bombs">3</span></span>
      <span class="score-item score-red">WOMEN: <span id="humansDisplay" data-defendher-target="humans">10</span></span>
    </div>
    
    <div id="instructions" class="instructions">
      <strong>Mission:</strong> Defend the women from alien abduction! Use your ship's laser and bombs to destroy enemies.<br>
      <strong>Controls:</strong> ARROW KEYS move, SPACEBAR fires laser, SHIFT drops bomb<br>
      <strong>Warning:</strong> If Landers reach the top with women, they become deadly Mutants!
    </div>
    
    <button id="startButton" 
            class="game-button start-button" 
            data-defendher-target="startButton">
      Launch Mission
    </button>
  </div>
  
  <div id="gameOver" 
       class="game-over game-over-hidden" 
       data-defendher-target="gameOver">
    <div class="game-over-content">
      <h2>Mission Complete</h2>
      <div class="final-stats">
        <div class="stat-line">Final Score: <span id="finalScoreDisplay">0</span></div>
        <div class="stat-line">Women Rescued: <span id="finalHumansDisplay">0</span></div>
        <div class="stat-line">Enemies Destroyed: <span id="finalEnemiesDisplay">0</span></div>
      </div>
      <button class="game-button restart-button" data-action="click->defendher#restart">
        New Mission
      </button>
    </div>
  </div>
  
  <div class="back-link">
    <%= link_to "← Back to Arcade", arcade_path %>
  </div>
</div>

<script nonce="<%= content_security_policy_nonce %>">
// DefendHer - Full DefendHer Game Implementation
// Based on detailed pseudocode specification

console.log('🚀 DefendHer: Initializing planetary defense system...');

class DefendHerGame {
  constructor() {
    console.log('DefendHerGame: Constructor called');
    this.canvas = document.getElementById('gameCanvas');
    this.ctx = this.canvas.getContext('2d');
    this.width = this.canvas.width;
    this.height = this.canvas.height;
    
    // Game state
    this.gameState = 'loading'; // loading, start, playing, gameOver, paused
    this.score = 0;
    this.lives = 3;
    this.wave = 1;
    this.bombs = 3;
    this.humansRescued = 0;
    this.enemiesDestroyed = 0;
    this.waveTransitioning = false;
    
    // World parameters
    this.worldWidth = 4000; // Smaller world
    this.scrollX = 0;
    this.cameraX = 0;
    
    // Debug and performance
    this.debugInfo = document.getElementById('debug');
    this.frameCount = 0;
    this.lastFpsUpdate = 0;
    this.fps = 0;
    this.lastTime = 0;
    
    // Visual effects
    this.screenShake = { x: 0, y: 0, intensity: 0, decay: 0 };
    this.flashScreen = null;
    this.backgroundPulse = 0;
    
    // Input handling
    this.keys = {};
    this.setupInput();
    
    // Entity management
    this.entities = [];
    this.particles = [];
    this.player = null;
    this.humans = [];
    this.terrain = [];
    this.stars = [];
    
    // Audio context for sound effects
    this.audioContext = null;
    this.initAudio();
    
    // Background image
    this.backgroundImage = new Image();
    this.backgroundImage.src = '<%= asset_path("arcade/defendher/Art/BG-mountains.png") %>';
    this.backgroundImageLoaded = false;
    this.backgroundImage.onload = () => {
      console.log('Background image loaded');
      this.backgroundImageLoaded = true;
    };
    
    // Audio files
    this.sounds = {};
    this.loadSounds();
    
    // Sprite sheet
    this.spriteSheet = new Image();
    this.spriteSheet.src = '<%= asset_path("arcade/defendher/Art/defendersprites.jpg") %>';
    this.spriteSheetLoaded = false;
    this.spriteSheet.onload = () => {
      console.log('Sprite sheet loaded successfully:', this.spriteSheet.width, 'x', this.spriteSheet.height);
      this.spriteSheetLoaded = true;
    };
    this.spriteSheet.onerror = (error) => {
      console.error('Failed to load sprite sheet:', error);
      console.error('Sprite sheet URL:', this.spriteSheet.src);
    };
    
    console.log('DefenderGame: Initialization complete');
    this.init();
  }
  
  initAudio() {
    try {
      this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
      console.log('DefendHerGame: Audio context initialized');
    } catch (e) {
      console.warn('DefendHerGame: Audio not available:', e);
    }
  }
  
  playSound(frequency, duration, type = 'square') {
    if (!this.audioContext) return;
    
    const oscillator = this.audioContext.createOscillator();
    const gain = this.audioContext.createGain();
    
    oscillator.connect(gain);
    gain.connect(this.audioContext.destination);
    
    oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
    oscillator.type = type;
    
    gain.gain.setValueAtTime(0.1, this.audioContext.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
    
    oscillator.start(this.audioContext.currentTime);
    oscillator.stop(this.audioContext.currentTime + duration);
  }
  
  loadSounds() {
    const soundFiles = {
      laser: '<%= asset_path("arcade/defendher/Sounds/Laser Weapons Sound Pack/Free/light_blast_1.wav") %>',
      explosion: '<%= asset_path("arcade/defendher/Sounds/436871__mozfoo__distant-explosion.wav") %>',
      gameStart: '<%= asset_path("arcade/defendher/Sounds/defstart.wav") %>',
      enemySound: '<%= asset_path("arcade/defendher/Sounds/deflande.wav") %>',
      bomb: '<%= asset_path("arcade/defendher/Sounds/Laser Weapons Sound Pack/Free/heavy_blast_001.wav") %>'
    };
    
    Object.keys(soundFiles).forEach(key => {
      const audio = new Audio();
      audio.src = soundFiles[key];
      audio.preload = 'auto';
      audio.volume = 0.3;
      this.sounds[key] = audio;
    });
    
    console.log('Audio files loaded:', Object.keys(this.sounds));
  }
  
  playAudioFile(soundName) {
    if (this.sounds[soundName]) {
      try {
        const sound = this.sounds[soundName].cloneNode();
        sound.currentTime = 0;
        sound.play().catch(e => console.warn('Could not play sound:', soundName, e));
      } catch (e) {
        console.warn('Error playing sound:', soundName, e);
      }
    }
  }
  
  drawSprite(ctx, spriteX, spriteY, spriteWidth, spriteHeight, destX, destY, destWidth = spriteWidth, destHeight = spriteHeight) {
    if (this.spriteSheetLoaded && this.spriteSheet.complete) {
      console.log(`Drawing sprite: (${spriteX},${spriteY}) size ${spriteWidth}x${spriteHeight} at (${destX},${destY})`);
      try {
        ctx.drawImage(
          this.spriteSheet,
          spriteX, spriteY, spriteWidth, spriteHeight,
          destX - destWidth/2, destY - destHeight/2, destWidth, destHeight
        );
        return true;
      } catch (error) {
        console.error('Error drawing sprite:', error);
        return false;
      }
    } else {
      console.log('Sprite sheet not ready:', this.spriteSheetLoaded, this.spriteSheet.complete);
      return false;
    }
  }
  
  init() {
    console.log('DefendHerGame: Initializing game world...');
    
    // Generate terrain
    this.generateTerrain();
    
    // Generate starfield
    this.generateStarfield();
    
    // Create player
    this.player = new DefendHerShip(this.width / 2, this.height / 2);
    this.entities.push(this.player);
    
    // Place humans on terrain
    this.spawnHumans();
    
    // Spawn initial enemies
    this.spawnEnemyWave();
    
    this.updateDebug('Planet defense system ready! Press SPACE to begin mission.');
    this.gameState = 'start';
    
    // Hide loading screen
    setTimeout(() => {
      const loadingScreen = document.getElementById('loadingScreen');
      if (loadingScreen) {
        loadingScreen.style.display = 'none';
      }
    }, 1500);
  }
  
  generateTerrain() {
    console.log('DefendHerGame: Generating terrain...');
    this.terrain = [];
    const segments = 200;
    for (let i = 0; i <= segments; i++) {
      const x = (i / segments) * this.worldWidth;
      const y = this.height - 100 + Math.sin(i * 0.1) * 50 + Math.random() * 30;
      this.terrain.push({ x, y });
    }
  }
  
  generateStarfield() {
    console.log('DefendHerGame: Generating starfield...');
    this.stars = [];
    for (let i = 0; i < 200; i++) {
      this.stars.push({
        x: Math.random() * this.worldWidth,
        y: Math.random() * this.height * 0.8,
        brightness: Math.random(),
        depth: Math.random() * 3 + 1 // Parallax depth
      });
    }
  }
  
  spawnHumans() {
    console.log('DefendHerGame: Spawning women...');
    this.humans = [];
    const humanCount = 10;
    for (let i = 0; i < humanCount; i++) {
      const x = (Math.random() * 0.8 + 0.1) * this.worldWidth; // Keep away from edges
      const terrainY = this.getTerrainHeightAt(x);
      const human = new Woman(x, terrainY - 20);
      this.humans.push(human);
      this.entities.push(human);
    }
  }
  
  spawnEnemyWave() {
    console.log(`DefendHerGame: Spawning wave ${this.wave}...`);
    const baseCount = Math.min(3 + this.wave, 15); // Cap enemy count to prevent explosion
    
    // Spawn Landers
    for (let i = 0; i < baseCount; i++) {
      const x = Math.random() * this.worldWidth;
      const y = Math.random() * this.height * 0.3 + 50;
      this.entities.push(new Lander(x, y));
    }
    
    // Spawn Bombers (fewer)
    for (let i = 0; i < Math.floor(baseCount / 2); i++) {
      const x = Math.random() * this.worldWidth;
      const y = Math.random() * this.height * 0.4 + 50;
      this.entities.push(new Bomber(x, y));
    }
    
    // Spawn Pods
    for (let i = 0; i < Math.max(1, Math.floor(this.wave / 2)); i++) {
      const x = Math.random() * this.worldWidth;
      const y = Math.random() * this.height * 0.6 + 100;
      this.entities.push(new Pod(x, y));
    }
  }
  
  getTerrainHeightAt(x) {
    // Find terrain height at given x coordinate
    const wrappedX = ((x % this.worldWidth) + this.worldWidth) % this.worldWidth;
    
    for (let i = 0; i < this.terrain.length - 1; i++) {
      const curr = this.terrain[i];
      const next = this.terrain[i + 1];
      
      if (wrappedX >= curr.x && wrappedX <= next.x) {
        // Linear interpolation
        const t = (wrappedX - curr.x) / (next.x - curr.x);
        return curr.y + (next.y - curr.y) * t;
      }
    }
    
    return this.height - 100; // Fallback
  }
  
  setupInput() {
    document.addEventListener('keydown', (e) => {
      this.keys[e.code] = true;
      
      // Prevent default for all game keys to stop browser scrolling
      if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 
           'KeyW', 'KeyA', 'KeyS', 'KeyD', 'ShiftLeft', 'ShiftRight', 'Escape'].includes(e.code)) {
        e.preventDefault();
      }
      
      if (e.code === 'Space') {
        if (this.gameState === 'start') {
          this.startGame();
        } else if (this.gameState === 'gameOver') {
          this.restart();
        }
        // Resume audio context on user interaction
        if (this.audioContext && this.audioContext.state === 'suspended') {
          this.audioContext.resume();
        }
      }
      
      if (e.code === 'Escape') {
        this.togglePause();
      }
      
      // Debug sprite cycling
      if (e.code === 'KeyT') {
        if (!window.debugSpriteIndex) window.debugSpriteIndex = 0;
        window.debugSpriteIndex++;
        console.log('Debug: Switched to sprite index', window.debugSpriteIndex);
      }
    });
    
    document.addEventListener('keyup', (e) => {
      this.keys[e.code] = false;
      
      // Prevent default for game keys
      if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 
           'KeyW', 'KeyA', 'KeyS', 'KeyD', 'ShiftLeft', 'ShiftRight'].includes(e.code)) {
        e.preventDefault();
      }
    });
    
    // Focus canvas when clicked and prevent default scrolling
    this.canvas.addEventListener('click', () => {
      this.canvas.focus();
    });
    
    // Prevent canvas from scrolling on focus
    this.canvas.addEventListener('keydown', (e) => {
      e.preventDefault();
    });
  }
  
  startGame() {
    console.log('DefendHerGame: Mission started!');
    this.gameState = 'playing';
    document.getElementById('startScreen').style.display = 'none';
    this.updateDebug('Mission active! Defend the women!');
    this.playAudioFile('gameStart');
  }
  
  restart() {
    console.log('DefendHerGame: Restarting mission...');
    this.score = 0;
    this.lives = 3;
    this.wave = 1;
    this.bombs = 3;
    this.humansRescued = 0;
    this.enemiesDestroyed = 0;
    this.scrollX = 0;
    this.cameraX = 0;
    this.entities = [];
    this.particles = [];
    this.gameState = 'playing';
    document.getElementById('gameOverScreen').style.display = 'none';
    this.init();
  }
  
  togglePause() {
    if (this.gameState === 'playing') {
      this.gameState = 'paused';
      this.updateDebug('Mission paused. Press ESC to resume.');
    } else if (this.gameState === 'paused') {
      this.gameState = 'playing';
      this.updateDebug('Mission resumed!');
    }
  }
  
  update(deltaTime) {
    if (this.gameState !== 'playing') return;
    
    // Handle player input
    this.handlePlayerInput(deltaTime);
    
    // Update entities
    for (let i = this.entities.length - 1; i >= 0; i--) {
      const entity = this.entities[i];
      if (entity.update) {
        entity.update(deltaTime, this);
      }
      
      // Remove dead entities
      if (entity.alive === false) {
        if (entity.type === 'enemy') {
          this.enemiesDestroyed++;
          this.score += entity.points || 100;
          this.spawnExplosion(entity.x, entity.y, '#ff66cc');
          this.playAudioFile('explosion');
          
          // Small screen shake for enemy destruction
          this.addScreenShake(3, 0.2);
        }
        this.entities.splice(i, 1);
      }
    }
    
    // Update particles
    for (let i = this.particles.length - 1; i >= 0; i--) {
      const particle = this.particles[i];
      particle.update(deltaTime);
      if (particle.life <= 0) {
        this.particles.splice(i, 1);
      }
    }
    
    // Update camera
    this.updateCamera();
    
    // Check collisions
    this.checkCollisions();
    
    // Check wave completion
    this.checkWaveCompletion();
    
    // Check game over conditions
    this.checkGameOver();
    
    // Update visual effects
    this.updateVisualEffects();
    
    // Update UI
    this.updateUI();
  }
  
  handlePlayerInput(deltaTime) {
    if (!this.player || !this.player.alive) return;
    
    const speed = 300;
    
    if (this.keys['ArrowLeft'] || this.keys['KeyA']) {
      this.player.x -= speed * deltaTime;
      this.player.facing = -1;
    }
    if (this.keys['ArrowRight'] || this.keys['KeyD']) {
      this.player.x += speed * deltaTime;
      this.player.facing = 1;
    }
    if (this.keys['ArrowUp'] || this.keys['KeyW']) {
      this.player.y -= speed * deltaTime;
    }
    if (this.keys['ArrowDown'] || this.keys['KeyS']) {
      this.player.y += speed * deltaTime;
    }
    
    // Wrap around world horizontally
    if (this.player.x < 0) this.player.x = this.worldWidth - 1;
    if (this.player.x >= this.worldWidth) this.player.x = 0;
    
    // Clamp vertically
    this.player.y = Math.max(20, Math.min(this.height - 20, this.player.y));
    
    // Shooting
    if (this.keys['Space']) {
      this.player.shoot(this);
    }
    
    // Bombing
    if (this.keys['ShiftLeft'] || this.keys['ShiftRight']) {
      this.player.bomb(this);
    }
  }
  
  updateCamera() {
    // Keep camera centered on player with smooth following
    if (this.player && this.player.alive) {
      const targetCameraX = this.player.x - this.width / 2;
      
      // Check if player wrapped around the world
      const cameraDiff = targetCameraX - this.cameraX;
      
      // If the camera difference is too large (> half world), player likely wrapped
      if (Math.abs(cameraDiff) > this.worldWidth / 2) {
        // Snap camera immediately for world wrapping
        this.cameraX = targetCameraX;
      } else {
        // Normal smooth camera movement
        this.cameraX += cameraDiff * 0.15; // Slightly faster than before
      }
    }
  }
  
  checkCollisions() {
    // Player vs enemies
    if (this.player && this.player.alive && !this.player.invulnerable) {
      for (let entity of this.entities) {
        if (entity.type === 'enemy' && this.distance(this.player, entity) < 25) {
          this.playerHit();
          break;
        }
      }
    }
    
    // Bullets vs enemies
    const bullets = this.entities.filter(e => e.type === 'bullet');
    const enemies = this.entities.filter(e => e.type === 'enemy');
    
    for (let bullet of bullets) {
      for (let enemy of enemies) {
        if (this.distance(bullet, enemy) < 20) {
          bullet.alive = false;
          
          // Special handling for Landers carrying humans
          if (enemy.type === 'enemy' && enemy.constructor.name === 'Lander' && enemy.abductedHuman) {
            // Drop the woman
            enemy.abductedHuman.state = 'falling';
            enemy.abductedHuman.y = enemy.y + 30;
            this.updateDebug('Lander destroyed! Woman falling - catch her!');
          }
          
          // Special handling for Pods - they split into Swarmers
          if (enemy.constructor.name === 'Pod') {
            enemy.die(this);
          }
          
          enemy.alive = false;
          break;
        }
      }
    }
    
    // Player catching falling humans
    if (this.player && this.player.alive) {
      for (let human of this.humans) {
        if (human.state === 'falling' && this.distance(this.player, human) < 40) {
          human.state = 'rescued';
          human.alive = true; // Ensure they stay alive
          this.humansRescued++;
          this.score += 500;
          this.updateDebug('Woman rescued! +500 points - return to ground!');
          this.playSound(440, 0.3, 'sine');
          
          // Teleport human back to safe ground position
          setTimeout(() => {
            const safeX = Math.random() * this.worldWidth;
            const groundY = this.getTerrainHeightAt(safeX);
            human.x = safeX;
            human.y = groundY - 20;
            human.state = 'walking';
            this.updateDebug('Woman safely returned to ground!');
          }, 1000);
        }
      }
    }
  }
  
  distance(a, b) {
    const dx = a.x - b.x;
    const dy = a.y - b.y;
    return Math.sqrt(dx * dx + dy * dy);
  }
  
  playerHit() {
    if (!this.player || !this.player.alive) return;
    
    this.lives--;
    this.spawnExplosion(this.player.x, this.player.y, '#ff66cc');
    this.playSound(100, 0.5, 'sawtooth');
    this.updateDebug(`Ship destroyed! Lives remaining: ${this.lives}`);
    
    // Screen shake on player hit
    this.addScreenShake(15, 0.8);
    
    // Screen flash
    this.flashScreen = { intensity: 0.7, decay: 2.0 };
    
    if (this.lives > 0) {
      // Make player temporarily invulnerable but still alive for respawn
      this.player.invulnerable = true;
      
      // Respawn player after delay
      setTimeout(() => {
        if (this.player) {
          this.player.x = this.width / 2;
          this.player.y = this.height / 2;
          this.player.alive = true;
          this.player.invulnerable = false;
        }
      }, 2000);
    } else {
      // Only set player dead if no lives left
      this.player.alive = false;
    }
  }
  
  checkWaveCompletion() {
    // Prevent wave completion check from running multiple times
    if (this.waveTransitioning) return;
    
    const enemies = this.entities.filter(e => e.type === 'enemy');
    if (enemies.length === 0) {
      this.waveTransitioning = true;
      this.wave++;
      
      // Cap wave number to prevent overflow bug
      if (this.wave > 50) {
        console.warn('Wave number exceeded 50, resetting to 50');
        this.wave = 50;
      }
      
      this.bombs = Math.min(5, this.bombs + 1); // Bonus bomb
      this.updateDebug(`Wave ${this.wave} incoming! Bonus bomb awarded.`);
      
      // Brief pause before new wave
      setTimeout(() => {
        this.spawnEnemyWave();
        this.updateDebug(`Wave ${this.wave} launched!`);
        this.waveTransitioning = false;
      }, 500); // Reduced from 2000ms to 500ms
    }
  }
  
  checkGameOver() {
    if (this.lives <= 0) {
      this.gameState = 'gameOver';
      document.getElementById('gameOverScreen').style.display = 'block';
      document.getElementById('finalScore').textContent = this.score;
      document.getElementById('humansRescued').textContent = this.humansRescued;
      this.updateDebug('Mission failed. All ships lost.');
    }
    
    // Check if all women are dead
    const aliveHumans = this.humans.filter(h => h.alive && h.state !== 'abducted');
    if (aliveHumans.length === 0) {
      this.gameState = 'gameOver';
      document.getElementById('gameOverScreen').style.display = 'block';
      document.getElementById('finalScore').textContent = this.score;
      this.updateDebug('Mission failed. All women lost.');
    }
  }
  
  spawnExplosion(x, y, color) {
    // Enhanced explosion with more particles and effects
    for (let i = 0; i < 20; i++) {
      const particle = new Particle(x, y, color);
      // Some particles move faster for dramatic effect
      if (Math.random() > 0.7) {
        particle.vx *= 1.5;
        particle.vy *= 1.5;
        particle.glow = true;
      }
      this.particles.push(particle);
    }
    
    // Add some white-hot core particles
    for (let i = 0; i < 5; i++) {
      const coreParticle = new Particle(x, y, '#ffffff');
      coreParticle.life = 0.8;
      coreParticle.decay = 1.5;
      coreParticle.glow = true;
      coreParticle.size = 2;
      this.particles.push(coreParticle);
    }
  }
  
  spawnMegaExplosion(x, y) {
    // Massive bomb explosion with cinematic colors
    const colors = ['#ff66cc', '#cc44aa', '#9933bb', '#6622cc', '#ffffff'];
    
    // Multiple explosion rings
    for (let ring = 0; ring < 6; ring++) {
      setTimeout(() => {
        for (let i = 0; i < 35; i++) {
          const particle = new Particle(x, y, colors[ring % colors.length]);
          particle.vx = (Math.random() - 0.5) * 500 * (ring + 1);
          particle.vy = (Math.random() - 0.5) * 500 * (ring + 1);
          particle.life = 2.5; // Even longer lasting
          particle.decay = 0.4; // Slower decay
          particle.size = 1 + ring * 0.5; // Bigger particles in outer rings
          particle.glow = true;
          this.particles.push(particle);
        }
      }, ring * 80);
    }
    
    // Intense screen effects
    this.flashScreen = { intensity: 1.0, decay: 2.5 };
    this.addScreenShake(25, 1.2);
  }
  
  render() {
    // Clear canvas with dynamic background
    this.ctx.fillStyle = '#000011';
    this.ctx.fillRect(0, 0, this.width, this.height);
    
    // Apply screen shake
    this.ctx.save();
    this.ctx.translate(this.screenShake.x, this.screenShake.y);
    
    // Save context for scrolling
    this.ctx.save();
    this.ctx.translate(-this.cameraX, 0);
    
    // Draw background mountains with parallax - DISABLED due to sprite issues
    if (false && this.backgroundImageLoaded) {
      const parallaxSpeed = 0.3;
      const bgX = (-this.cameraX * parallaxSpeed) % this.backgroundImage.width;
      
      // Draw background image with tiling
      this.ctx.drawImage(this.backgroundImage, bgX, this.height - this.backgroundImage.height);
      this.ctx.drawImage(this.backgroundImage, bgX + this.backgroundImage.width, this.height - this.backgroundImage.height);
      if (bgX > 0) {
        this.ctx.drawImage(this.backgroundImage, bgX - this.backgroundImage.width, this.height - this.backgroundImage.height);
      }
    }
    
    // Draw starfield with parallax
    this.drawStarfield();
    
    // Draw terrain
    this.drawTerrain();
    
    // Draw entities with improved world wrapping
    console.log(`Rendering ${this.entities.length} entities`);
    for (let entity of this.entities) {
      if (entity.render) {
        // Draw entity if visible
        if (this.isVisible(entity)) {
          entity.render(this.ctx);
        }
        
        // Add simple wrapping for entities near world edges
        const savedX = entity.x;
        
        // If entity is near left edge, also check if it should appear on right
        if (entity.x < this.width) {
          entity.x = savedX + this.worldWidth;
          if (this.isVisible(entity)) {
            entity.render(this.ctx);
          }
          entity.x = savedX; // restore
        }
        
        // If entity is near right edge, also check if it should appear on left
        if (entity.x > this.worldWidth - this.width) {
          entity.x = savedX - this.worldWidth;
          if (this.isVisible(entity)) {
            entity.render(this.ctx);
          }
          entity.x = savedX; // restore
        }
      }
    }
    
    // Restore context
    this.ctx.restore();
    
    // Draw particles (screen space)
    for (let particle of this.particles) {
      particle.render(this.ctx, this.cameraX);
    }
    
    // Restore from screen shake
    this.ctx.restore();
    
    // Draw UI (always on screen) - radar disabled
    // this.drawRadar();
    
    // Screen flash effect for explosions
    if (this.flashScreen && this.flashScreen.intensity > 0) {
      const flashColor = `rgba(255, 102, 204, ${this.flashScreen.intensity * 0.4})`;
      this.ctx.fillStyle = flashColor;
      this.ctx.fillRect(0, 0, this.width, this.height);
      this.flashScreen.intensity -= this.flashScreen.decay * (1/60); // Assume 60 FPS
      if (this.flashScreen.intensity <= 0) {
        this.flashScreen = null;
      }
    }
    
    // Subtle background pulse effect
    if (this.backgroundPulse > 0) {
      const pulseAlpha = this.backgroundPulse * 0.1;
      this.ctx.fillStyle = `rgba(102, 51, 153, ${pulseAlpha})`;
      this.ctx.fillRect(0, 0, this.width, this.height);
    }
    
    // Update FPS counter
    // Visual effects are updated in the main update loop
    
    this.frameCount++;
    const now = performance.now();
    if (now - this.lastFpsUpdate > 1000) {
      this.fps = Math.round((this.frameCount * 1000) / (now - this.lastFpsUpdate));
      this.frameCount = 0;
      this.lastFpsUpdate = now;
    }
  }
  
  isVisible(entity) {
    const visible = entity.x > this.cameraX - 100 && entity.x < this.cameraX + this.width + 100;
    if (!visible) {
      console.log(`Entity at (${entity.x}, ${entity.y}) not visible. Camera: ${this.cameraX}, Width: ${this.width}`);
    }
    return visible;
  }
  
  drawStarfield() {
    this.ctx.save();
    
    for (let star of this.stars) {
      const parallax = 1 / star.depth;
      const x = star.x * parallax;
      const y = star.y;
      
      // Draw star at multiple positions for seamless wrapping
      const positions = [
        x,
        x + this.worldWidth,
        x - this.worldWidth
      ];
      
      // Twinkling effect
      const twinkle = Math.sin(Date.now() * 0.003 + star.x) * 0.3 + 0.7;
      const alpha = star.brightness * twinkle * 0.9;
      
      // Draw stars at all visible positions
      for (let starX of positions) {
        // Only draw if visible
        if (starX > this.cameraX - 10 && starX < this.cameraX + this.width + 10) {
          // Different star colors and sizes based on depth
          if (star.depth > 2.5) {
            // Distant stars - small and dim
            this.ctx.fillStyle = `rgba(200, 200, 255, ${alpha * 0.6})`;
            this.ctx.fillRect(starX, y, 1, 1);
          } else if (star.depth > 1.5) {
            // Medium stars - white/blue
            this.ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
            this.ctx.fillRect(starX, y, 2, 2);
            
            // Bright stars get a glow
            if (star.brightness > 0.8) {
              this.ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.3})`;
              this.ctx.fillRect(starX - 1, y - 1, 4, 4);
            }
          } else {
            // Close bright stars - larger with colors
            const starColors = ['#ffffff', '#ffdddd', '#ddddff', '#ffffdd'];
            const colorIndex = Math.floor(star.x / 100) % starColors.length;
            this.ctx.fillStyle = starColors[colorIndex];
            this.ctx.globalAlpha = alpha;
            this.ctx.fillRect(starX, y, 2, 2);
            
            // Bright star cross pattern
            if (star.brightness > 0.9) {
              this.ctx.globalAlpha = alpha * 0.5;
              this.ctx.fillRect(starX - 2, y, 6, 1);
              this.ctx.fillRect(starX, y - 2, 1, 6);
            }
          }
        }
      }
    }
    
    this.ctx.globalAlpha = 1;
    this.ctx.restore();
  }
  
  drawTerrain() {
    this.ctx.save();
    
    // Draw terrain with wrapping - draw multiple copies for seamless wrapping
    const drawTerrainSection = (offsetX) => {
      // Multi-layer terrain with atmospheric depth
      const gradient = this.ctx.createLinearGradient(0, this.height - 300, 0, this.height);
      gradient.addColorStop(0, '#2a0845');
      gradient.addColorStop(0.3, '#1a0530');
      gradient.addColorStop(0.7, '#0f0320');
      gradient.addColorStop(1, '#050110');
      this.ctx.fillStyle = gradient;
      
      // Create filled terrain path
      this.ctx.beginPath();
      this.ctx.moveTo(this.terrain[0].x + offsetX, this.terrain[0].y);
      
      for (let i = 1; i < this.terrain.length; i++) {
        this.ctx.lineTo(this.terrain[i].x + offsetX, this.terrain[i].y);
      }
      
      // Complete the fill to bottom of screen
      this.ctx.lineTo(this.terrain[this.terrain.length - 1].x + offsetX, this.height);
      this.ctx.lineTo(this.terrain[0].x + offsetX, this.height);
      this.ctx.closePath();
      this.ctx.fill();
      
      // Add atmospheric glow to terrain surface
      const surfaceGradient = this.ctx.createLinearGradient(0, this.terrain[0].y - 20, 0, this.terrain[0].y + 20);
      surfaceGradient.addColorStop(0, 'rgba(255,102,204,0)');
      surfaceGradient.addColorStop(0.5, 'rgba(255,102,204,0.3)');
      surfaceGradient.addColorStop(1, 'rgba(255,102,204,0)');
      this.ctx.fillStyle = surfaceGradient;
      
      this.ctx.beginPath();
      this.ctx.moveTo(this.terrain[0].x + offsetX, this.terrain[0].y - 20);
      for (let i = 1; i < this.terrain.length; i++) {
        this.ctx.lineTo(this.terrain[i].x + offsetX, this.terrain[i].y - 20);
      }
      for (let i = this.terrain.length - 1; i >= 0; i--) {
        this.ctx.lineTo(this.terrain[i].x + offsetX, this.terrain[i].y + 20);
      }
      this.ctx.closePath();
      this.ctx.fill();
      
      // Draw glowing terrain outline with multiple layers
      this.ctx.save();
      
      // Outer glow
      this.ctx.strokeStyle = '#ff66cc';
      this.ctx.lineWidth = 4;
      this.ctx.shadowColor = '#ff66cc';
      this.ctx.shadowBlur = 15;
      this.ctx.globalAlpha = 0.6;
      this.ctx.beginPath();
      
      for (let i = 0; i < this.terrain.length; i++) {
        const point = this.terrain[i];
        if (i === 0) {
          this.ctx.moveTo(point.x + offsetX, point.y);
        } else {
          this.ctx.lineTo(point.x + offsetX, point.y);
        }
      }
      this.ctx.stroke();
      
      // Inner bright line
      this.ctx.strokeStyle = '#ffccff';
      this.ctx.lineWidth = 2;
      this.ctx.shadowBlur = 8;
      this.ctx.globalAlpha = 0.9;
      this.ctx.beginPath();
      
      for (let i = 0; i < this.terrain.length; i++) {
        const point = this.terrain[i];
        if (i === 0) {
          this.ctx.moveTo(point.x + offsetX, point.y);
        } else {
          this.ctx.lineTo(point.x + offsetX, point.y);
        }
      }
      this.ctx.stroke();
      
      this.ctx.restore();
    };
    
    // Draw terrain sections with seamless wrapping
    // Always draw multiple terrain sections to prevent gaps
    drawTerrainSection(-this.worldWidth); // Left side
    drawTerrainSection(0);               // Main terrain  
    drawTerrainSection(this.worldWidth); // Right side
    
    this.ctx.restore();
  }
  
  drawRadar() {
    // Simple radar/scanner at bottom of screen
    const radarX = 20;
    const radarY = this.height - 80;
    const radarW = 200;
    const radarH = 60;
    
    this.ctx.strokeStyle = '#00aa00';
    this.ctx.strokeRect(radarX, radarY, radarW, radarH);
    
    // Show entities on radar
    for (let entity of this.entities) {
      let color = '#ffffff';
      if (entity.type === 'player') color = '#00ff00';
      else if (entity.type === 'enemy') color = '#ff0000';
      else if (entity.type === 'human') color = '#ffff00';
      
      const radarPosX = radarX + (entity.x / this.worldWidth) * radarW;
      const radarPosY = radarY + (entity.y / this.height) * radarH;
      
      this.ctx.fillStyle = color;
      this.ctx.fillRect(radarPosX - 1, radarPosY - 1, 2, 2);
    }
  }
  
  updateUI() {
    document.getElementById('score').textContent = this.score;
    document.getElementById('lives').textContent = this.lives;
    document.getElementById('wave').textContent = this.wave;
    document.getElementById('humanoids').textContent = this.humans.filter(h => h.alive).length;
    
    // Update main UI displays
    document.getElementById('scoreDisplay').textContent = this.score.toString().padStart(6, '0');
    document.getElementById('livesDisplay').textContent = this.lives;
    document.getElementById('bombsDisplay').textContent = this.bombs;
    document.getElementById('humansDisplay').textContent = this.humans.filter(h => h.alive).length;
  }
  
  addScreenShake(intensity, duration) {
    this.screenShake.intensity = intensity;
    this.screenShake.decay = intensity / (duration * 60); // Assume 60 FPS
  }
  
  updateVisualEffects() {
    // Update screen shake
    if (this.screenShake.intensity > 0) {
      const shakeAmount = this.screenShake.intensity;
      this.screenShake.x = (Math.random() - 0.5) * shakeAmount;
      this.screenShake.y = (Math.random() - 0.5) * shakeAmount;
      this.screenShake.intensity -= this.screenShake.decay;
      if (this.screenShake.intensity <= 0) {
        this.screenShake = { x: 0, y: 0, intensity: 0, decay: 0 };
      }
    }
    
    // Update background pulse
    this.backgroundPulse = Math.sin(Date.now() * 0.002) * 0.5 + 0.5;
  }
  
  updateDebug(message) {
    const debugDiv = document.getElementById('debug');
    const now = new Date().toLocaleTimeString();
    debugDiv.innerHTML = `
      <div>DEBUG (${now}):</div>
      <div>FPS: ${this.fps}</div>
      <div>Entities: ${this.entities.length}</div>
      <div>Particles: ${this.particles.length}</div>
      <div>State: ${this.gameState}</div>
      <div>Shake: ${Math.round(this.screenShake.intensity)}</div>
      <div>${message}</div>
    `;
  }
  
  gameLoop() {
    const now = performance.now();
    const deltaTime = Math.min((now - (this.lastTime || now)) / 1000, 0.016); // Cap at 60 FPS
    this.lastTime = now;
    
    this.update(deltaTime);
    this.render();
    
    requestAnimationFrame(() => this.gameLoop());
  }
  
  start() {
    console.log('DefendHerGame: Starting game loop...');
    this.updateDebug('Planetary defense system online! Press SPACE to begin.');
    this.gameLoop();
  }
}

// Game Entity Classes

class DefendHerShip {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.type = 'player';
    this.alive = true;
    this.facing = 1;
    this.lastShot = 0;
    this.shootCooldown = 150;
    this.lastBomb = 0;
    this.bombCooldown = 1000;
  }
  
  shoot(game) {
    const now = performance.now();
    if (now - this.lastShot > this.shootCooldown) {
      const bullet = new Bullet(this.x + this.facing * 20, this.y, this.facing, 0);
      game.entities.push(bullet);
      this.lastShot = now;
      game.playAudioFile('laser');
    }
  }
  
  bomb(game) {
    const now = performance.now();
    if (game.bombs > 0 && now - this.lastBomb > this.bombCooldown) {
      game.bombs--;
      this.lastBomb = now;
      
      // Massive visual explosion effect
      game.spawnMegaExplosion(this.x, this.y);
      game.playAudioFile('bomb');
      
      // Destroy all enemies on screen with larger radius
      const bombRadius = 300; // Much larger radius
      let enemiesDestroyed = 0;
      
      for (let entity of game.entities) {
        if (entity.type === 'enemy') {
          const distance = game.distance(this, entity);
          if (distance < bombRadius) {
            // Special handling for Landers with women
            if (entity.constructor.name === 'Lander' && entity.abductedHuman) {
              entity.abductedHuman.state = 'falling';
              entity.abductedHuman.y = entity.y + 30;
            }
            
            // Special handling for Pods
            if (entity.constructor.name === 'Pod') {
              entity.die(game);
            }
            
            entity.alive = false;
            enemiesDestroyed++;
            game.score += entity.points || 100;
          }
        }
      }
      
      game.updateDebug(`SMART BOMB! ${enemiesDestroyed} enemies destroyed! Bombs remaining: ${game.bombs}`);
    }
  }
  
  render(ctx) {
    if (!this.alive) return;
    
    ctx.save();
    
    // Use actual ship sprite from the sprite sheet
    let spriteDrawn = false;
    if (window.defendHerGame && window.defendHerGame.spriteSheetLoaded) {
      // Let's try the first obvious ship sprite - I can see some colorful sprites
      // Try several different coordinates to find a working ship sprite
      // Hero craft sprites are in row 4 from the top - the pink/magenta ships
      // These sprites have different dimensions and aren't on a regular grid
      // From the sprite sheet: forward, forward, reverse, reverse orientations
      const testCoordinates = [
        // Row 4 hero craft sprites - using exact measurements you provided
        { x: 0, y: 160, w: 60, h: 25 },    // Ship 1: 0-60, forward stopped
        { x: 90, y: 160, w: 60, h: 25 },   // Ship 2: 90-150, forward moving  
        { x: 170, y: 160, w: 60, h: 25 },  // Ship 3: 170-230, backward stopped
        { x: 255, y: 160, w: 60, h: 25 },  // Ship 4: 255-315, backward moving
        
        // Try slight vertical adjustments in case y=160 isn't perfect
        { x: 0, y: 158, w: 60, h: 25 },    // Ship 1, slightly higher
        { x: 90, y: 158, w: 60, h: 25 },   // Ship 2, slightly higher
        { x: 0, y: 162, w: 60, h: 25 },    // Ship 1, slightly lower
        { x: 90, y: 162, w: 60, h: 25 },   // Ship 2, slightly lower
        
        // Try different heights 
        { x: 0, y: 160, w: 60, h: 30 },    // Ship 1, taller
        { x: 90, y: 160, w: 60, h: 30 },   // Ship 2, taller
      ];
      
      // Add debug sprite cycling - use 'T' key to cycle through coordinates
      if (!window.debugSpriteIndex) window.debugSpriteIndex = 0;
      let sprite = testCoordinates[window.debugSpriteIndex % testCoordinates.length];
      
      // Use appropriate sprite based on facing direction (when not in debug mode)
      if (window.debugSpriteIndex === 0) { // Only use auto-selection for first sprite
        if (this.facing > 0) {
          sprite = testCoordinates[1]; // Forward moving sprite (90-150)
        } else {
          sprite = testCoordinates[3]; // Backward moving sprite (255-315)  
        }
      }
      
      
      // Draw sprite without flipping and preserve aspect ratio
      // Scale up but maintain the 60x25 proportions
      const scaleX = 48; // Scale width to 48px (60 * 0.8)
      const scaleY = 20; // Scale height to 20px (25 * 0.8) 
      spriteDrawn = window.defendHerGame.drawSprite(ctx, sprite.x, sprite.y, sprite.w, sprite.h, this.x, this.y, scaleX, scaleY);
    }
    
    if (!spriteDrawn) {
      // Visible fallback - bright green ship
      ctx.fillStyle = '#00ff00';
      ctx.fillRect(this.x - 16, this.y - 8, 32, 16);
      // Add a bright center
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(this.x - 4, this.y - 2, 8, 4);
    }
    
    // Shield shimmer effect
    if (Math.random() > 0.8) {
      ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
      ctx.fillRect(this.x - 20, this.y - 8, 40, 16);
    }
    
    ctx.restore();
  }
}

class Lander {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.type = 'enemy';
    this.alive = true;
    this.points = 150;
    this.speed = 80;
    this.direction = Math.random() * Math.PI * 2;
    this.state = 'hunting'; // hunting, abducting, ascending
    this.target = null;
    this.abductedHuman = null;
  }
  
  update(deltaTime, game) {
    if (this.state === 'hunting') {
      // Look for women to abduct
      const nearbyWomen = game.humans.filter(h => 
        h.alive && h.state === 'walking' && game.distance(this, h) < 200
      );
      
      if (nearbyWomen.length > 0) {
        this.target = nearbyWomen[Math.floor(Math.random() * nearbyWomen.length)];
        this.state = 'abducting';
      } else {
        // Random movement
        this.x += Math.cos(this.direction) * this.speed * deltaTime;
        this.y += Math.sin(this.direction) * this.speed * deltaTime;
        
        if (Math.random() < 0.02) {
          this.direction = Math.random() * Math.PI * 2;
        }
      }
    } else if (this.state === 'abducting') {
      if (this.target && this.target.alive) {
        // Move toward target woman
        const dx = this.target.x - this.x;
        const dy = this.target.y - this.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist > 30) {
          this.x += (dx / dist) * this.speed * deltaTime;
          this.y += (dy / dist) * this.speed * deltaTime;
        } else {
          // Start abduction
          this.target.state = 'abducted';
          this.abductedHuman = this.target;
          this.state = 'ascending';
        }
      } else {
        this.state = 'hunting';
      }
    } else if (this.state === 'ascending') {
      this.y -= this.speed * deltaTime;
      if (this.abductedHuman) {
        this.abductedHuman.x = this.x;
        this.abductedHuman.y = this.y + 30;
      }
      
      // Transform into mutant if reaching top
      if (this.y < 50) {
        game.entities.push(new Mutant(this.x, this.y));
        this.alive = false;
        if (this.abductedHuman) {
          this.abductedHuman.alive = false;
        }
      }
    }
    
    // World wrap
    this.x = ((this.x % game.worldWidth) + game.worldWidth) % game.worldWidth;
  }
  
  render(ctx) {
    console.log('Lander render called at', this.x, this.y, 'state:', this.state);
    ctx.save();
    
    // Temporarily use fallback rectangle while debugging sprites
    if (false && window.defendHerGame && window.defendHerGame.spriteSheetLoaded) {
      // Try one of the blue containers in the top row at approximately (450, 20)
      window.defendHerGame.drawSprite(ctx, 450, 20, 16, 16, this.x, this.y, 24, 24);
    } else {
      // Visible fallback - bright blue enemy
      ctx.fillStyle = '#0066ff';
      ctx.fillRect(this.x - 12, this.y - 8, 24, 16);
      // Add a bright red center to make it look menacing
      ctx.fillStyle = '#ff0000';
      ctx.fillRect(this.x - 6, this.y - 4, 12, 8);
    }
    
    // Cockpit/dome - sinister red glow
    ctx.fillStyle = '#cc3344';
    ctx.fillRect(this.x - 8, this.y - 10, 16, 8);
    ctx.fillStyle = '#ff6677';
    ctx.fillRect(this.x - 6, this.y - 9, 12, 6);
    
    // Dome highlight
    ctx.fillStyle = 'rgba(255, 102, 119, 0.6)';
    ctx.fillRect(this.x - 8, this.y - 10, 16, 3);
    
    // Wing/fin details - dark purple
    ctx.fillStyle = '#553366';
    ctx.fillRect(this.x - 16, this.y - 4, 4, 8);
    ctx.fillRect(this.x + 12, this.y - 4, 4, 8);
    
    // Wing tips - bright red
    ctx.fillStyle = '#ff4466';
    ctx.fillRect(this.x - 18, this.y - 2, 2, 4);
    ctx.fillRect(this.x + 16, this.y - 2, 2, 4);
    
    // Pulsating glow effect - menacing red
    const pulse = Math.sin(Date.now() * 0.01) * 0.5 + 0.5;
    ctx.fillStyle = `rgba(204, 51, 68, ${pulse * 0.4})`;
    ctx.fillRect(this.x - 14, this.y - 10, 28, 20);
    
    // Engine exhausts - purple energy
    ctx.fillStyle = '#cc66ff';
    if (Math.random() > 0.7) {
      ctx.fillRect(this.x - 10, this.y + 8, 2, 4);
      ctx.fillRect(this.x + 8, this.y + 8, 2, 4);
      // Energy trails
      ctx.fillStyle = 'rgba(204, 102, 255, 0.6)';
      ctx.fillRect(this.x - 10, this.y + 12, 2, 6);
      ctx.fillRect(this.x + 8, this.y + 12, 2, 6);
    }
    
    // Abduction beam with particle effect - sinister pink beam
    if (this.state === 'abducting' || this.state === 'ascending') {
      // Main beam - pink energy
      ctx.strokeStyle = '#ff66cc';
      ctx.lineWidth = 4;
      ctx.globalAlpha = 0.8;
      ctx.beginPath();
      ctx.moveTo(this.x, this.y + 8);
      ctx.lineTo(this.x, this.y + 50);
      ctx.stroke();
      
      // Outer beam glow
      ctx.strokeStyle = 'rgba(255, 102, 204, 0.4)';
      ctx.lineWidth = 8;
      ctx.globalAlpha = 0.6;
      ctx.beginPath();
      ctx.moveTo(this.x, this.y + 8);
      ctx.lineTo(this.x, this.y + 50);
      ctx.stroke();
      
      // Beam particles - sparkling pink
      ctx.fillStyle = '#ff99dd';
      ctx.globalAlpha = 1;
      for (let i = 0; i < 12; i++) {
        const beamY = this.y + 8 + (i * 4);
        const sparkle = Math.sin(Date.now() * 0.02 + i) * 4;
        ctx.fillRect(this.x + sparkle - 1, beamY, 3, 3);
        // Secondary sparkles
        ctx.fillStyle = '#ffffff';
        if (Math.random() > 0.7) {
          ctx.fillRect(this.x + sparkle, beamY + 1, 1, 1);
        }
        ctx.fillStyle = '#ff99dd';
      }
      ctx.globalAlpha = 1;
    }
    
    ctx.restore();
  }
}

class Mutant {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.type = 'enemy';
    this.alive = true;
    this.points = 300;
    this.speed = 150;
    this.direction = 0;
  }
  
  update(deltaTime, game) {
    // Aggressively chase player
    if (game.player && game.player.alive) {
      const dx = game.player.x - this.x;
      const dy = game.player.y - this.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      if (dist > 0) {
        this.x += (dx / dist) * this.speed * deltaTime;
        this.y += (dy / dist) * this.speed * deltaTime;
      }
    }
    
    // Zigzag movement
    this.direction += deltaTime * 5;
    this.x += Math.sin(this.direction) * 30 * deltaTime;
    
    // World wrap
    this.x = ((this.x % game.worldWidth) + game.worldWidth) % game.worldWidth;
  }
  
  render(ctx) {
    ctx.save();
    
    // Mutant sprite - aggressive spiky design with plasma energy
    // Main body with plasma purple/pink gradient
    ctx.fillStyle = '#bb2266';
    ctx.fillRect(this.x - 10, this.y - 6, 20, 12);
    ctx.fillStyle = '#dd4488';
    ctx.fillRect(this.x - 8, this.y - 4, 16, 8);
    ctx.fillStyle = '#ff66aa';
    ctx.fillRect(this.x - 6, this.y - 2, 12, 4);
    
    // Energy core
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(this.x - 2, this.y - 1, 4, 2);
    
    // Aggressive spikes with plasma animation
    const spikeAnim = Math.sin(Date.now() * 0.02) * 2;
    ctx.fillStyle = '#bb2266';
    // Side spikes - larger and more menacing
    ctx.fillRect(this.x - 15 + spikeAnim, this.y - 4, 6, 8);
    ctx.fillRect(this.x + 9 - spikeAnim, this.y - 4, 6, 8);
    // Top/bottom spikes
    ctx.fillRect(this.x - 4, this.y - 11 - spikeAnim, 8, 6);
    ctx.fillRect(this.x - 4, this.y + 5 + spikeAnim, 8, 6);
    
    // Sharp spike tips - bright plasma
    ctx.fillStyle = '#ff66cc';
    ctx.fillRect(this.x - 17 + spikeAnim, this.y - 2, 3, 4);
    ctx.fillRect(this.x + 14 - spikeAnim, this.y - 2, 3, 4);
    ctx.fillRect(this.x - 2, this.y - 13 - spikeAnim, 4, 3);
    ctx.fillRect(this.x - 2, this.y + 10 + spikeAnim, 4, 3);
    
    // Plasma tips glow
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(this.x - 16 + spikeAnim, this.y - 1, 1, 2);
    ctx.fillRect(this.x + 15 - spikeAnim, this.y - 1, 1, 2);
    ctx.fillRect(this.x - 1, this.y - 12 - spikeAnim, 2, 1);
    ctx.fillRect(this.x - 1, this.y + 11 + spikeAnim, 2, 1);
    
    // Angry plasma eyes/sensors
    ctx.fillStyle = '#66ccff';
    ctx.fillRect(this.x - 6, this.y - 4, 3, 2);
    ctx.fillRect(this.x + 3, this.y - 4, 3, 2);
    
    // Eye glow
    ctx.fillStyle = 'rgba(102, 204, 255, 0.8)';
    ctx.fillRect(this.x - 7, this.y - 5, 5, 4);
    ctx.fillRect(this.x + 2, this.y - 5, 5, 4);
    
    // Bright eye centers
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(this.x - 5, this.y - 4, 1, 1);
    ctx.fillRect(this.x + 4, this.y - 4, 1, 1);
    
    // Plasma energy trail effect
    const trailLength = 8;
    for (let i = 0; i < trailLength; i++) {
      const alpha = (trailLength - i) / trailLength * 0.4;
      ctx.fillStyle = `rgba(187, 34, 102, ${alpha})`;
      const trailX = this.x - (i * 3);
      ctx.fillRect(trailX - 6, this.y - 4, 12, 8);
      
      // Bright trail core
      if (i < 3) {
        ctx.fillStyle = `rgba(255, 102, 204, ${alpha * 0.8})`;
        ctx.fillRect(trailX - 3, this.y - 2, 6, 4);
      }
    }
    
    ctx.restore();
  }
}

class Bomber {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.type = 'enemy';
    this.alive = true;
    this.points = 250;
    this.speed = 60;
    this.direction = Math.random() * Math.PI * 2;
    this.lastMine = 0;
    this.mineCooldown = 2000;
  }
  
  update(deltaTime, game) {
    this.x += Math.cos(this.direction) * this.speed * deltaTime;
    this.y += Math.sin(this.direction) * this.speed * deltaTime;
    
    // Change direction occasionally
    if (Math.random() < 0.01) {
      this.direction = Math.random() * Math.PI * 2;
    }
    
    // Drop mines
    const now = performance.now();
    if (now - this.lastMine > this.mineCooldown) {
      game.entities.push(new Mine(this.x, this.y + 20));
      this.lastMine = now;
    }
    
    // World wrap
    this.x = ((this.x % game.worldWidth) + game.worldWidth) % game.worldWidth;
    this.y = Math.max(50, Math.min(game.height * 0.6, this.y));
  }
  
  render(ctx) {
    ctx.save();
    
    // Bomber sprite - large bulky design with dark metallic finish
    // Main hull - dark purple metallic
    ctx.fillStyle = '#665588';
    ctx.fillRect(this.x - 16, this.y - 10, 32, 20);
    ctx.fillStyle = '#4d4466';
    ctx.fillRect(this.x - 14, this.y - 8, 28, 16);
    ctx.fillStyle = '#332244';
    ctx.fillRect(this.x - 12, this.y - 6, 24, 12);
    
    // Hull highlights
    ctx.fillStyle = '#8877aa';
    ctx.fillRect(this.x - 16, this.y - 10, 32, 3);
    
    // Cockpit/control section - menacing red-orange
    ctx.fillStyle = '#cc4466';
    ctx.fillRect(this.x - 8, this.y - 8, 16, 8);
    ctx.fillStyle = '#aa2244';
    ctx.fillRect(this.x - 6, this.y - 7, 12, 6);
    
    // Cockpit glow
    ctx.fillStyle = 'rgba(204, 68, 102, 0.6)';
    ctx.fillRect(this.x - 9, this.y - 9, 18, 10);
    
    // Engine pods - dark metallic
    ctx.fillStyle = '#221133';
    ctx.fillRect(this.x - 18, this.y - 6, 4, 12);
    ctx.fillRect(this.x + 14, this.y - 6, 4, 12);
    
    // Engine glow - purple plasma
    ctx.fillStyle = '#aa66ff';
    if (Math.random() > 0.6) {
      ctx.fillRect(this.x - 20, this.y - 4, 2, 8);
      ctx.fillRect(this.x + 18, this.y - 4, 2, 8);
      // Engine trails
      ctx.fillStyle = 'rgba(170, 102, 255, 0.6)';
      ctx.fillRect(this.x - 22, this.y - 2, 2, 4);
      ctx.fillRect(this.x + 20, this.y - 2, 2, 4);
    }
    
    // Bomb bay doors (slightly open)
    ctx.fillStyle = '#333333';
    ctx.fillRect(this.x - 4, this.y + 10, 8, 4);
    ctx.fillStyle = '#555555';
    ctx.fillRect(this.x - 3, this.y + 11, 6, 2);
    
    // Warning lights (blinking) - pink/purple theme
    const blinkState = Math.floor(Date.now() / 500) % 2;
    if (blinkState) {
      ctx.fillStyle = '#ffccdd';
      ctx.fillRect(this.x - 2, this.y - 2, 4, 4);
      ctx.fillRect(this.x - 10, this.y + 6, 3, 3);
      ctx.fillRect(this.x + 7, this.y + 6, 3, 3);
      // Light glow
      ctx.fillStyle = 'rgba(255, 204, 221, 0.4)';
      ctx.fillRect(this.x - 4, this.y - 4, 8, 8);
    } else {
      ctx.fillStyle = '#ff4477';
      ctx.fillRect(this.x - 2, this.y - 2, 4, 4);
      ctx.fillRect(this.x - 10, this.y + 6, 3, 3);
      ctx.fillRect(this.x + 7, this.y + 6, 3, 3);
    }
    
    // Antenna/sensor array
    ctx.fillStyle = '#cccccc';
    ctx.fillRect(this.x - 1, this.y - 14, 2, 6);
    ctx.fillRect(this.x - 3, this.y - 12, 6, 1);
    
    ctx.restore();
  }
}

class Pod {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.type = 'enemy';
    this.alive = true;
    this.points = 200;
    this.bobOffset = Math.random() * Math.PI * 2;
    this.originalY = y;
  }
  
  update(deltaTime, game) {
    this.bobOffset += deltaTime * 3;
    this.y = this.originalY + Math.sin(this.bobOffset) * 20;
  }
  
  die(game) {
    // Split into swarmers
    for (let i = 0; i < 5; i++) {
      const angle = (i / 5) * Math.PI * 2;
      const swarmer = new Swarmer(this.x, this.y);
      swarmer.direction = angle;
      game.entities.push(swarmer);
    }
    game.spawnExplosion(this.x, this.y, '#aa00ff');
  }
  
  render(ctx) {
    ctx.save();
    
    // Pod sprite - glowing orb design
    const pulse = Math.sin(this.bobOffset) * 0.3 + 0.7;
    
    // Outer glow
    ctx.fillStyle = `rgba(170, 0, 255, ${pulse * 0.2})`;
    ctx.beginPath();
    ctx.arc(this.x, this.y, 16, 0, Math.PI * 2);
    ctx.fill();
    
    // Main body
    ctx.fillStyle = '#aa00ff';
    ctx.beginPath();
    ctx.arc(this.x, this.y, 12, 0, Math.PI * 2);
    ctx.fill();
    
    // Inner core
    ctx.fillStyle = '#ff88ff';
    ctx.beginPath();
    ctx.arc(this.x, this.y, 8, 0, Math.PI * 2);
    ctx.fill();
    
    // Bright center
    ctx.fillStyle = `rgba(255, 255, 255, ${pulse})`;
    ctx.beginPath();
    ctx.arc(this.x, this.y, 4, 0, Math.PI * 2);
    ctx.fill();
    
    // Energy rings
    for (let i = 0; i < 3; i++) {
      const ringSize = 6 + (i * 3);
      const ringPulse = Math.sin(this.bobOffset + i) * 0.5 + 0.5;
      ctx.strokeStyle = `rgba(255, 136, 255, ${ringPulse * 0.6})`;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(this.x, this.y, ringSize, 0, Math.PI * 2);
      ctx.stroke();
    }
    
    // Energy sparks around the pod
    for (let i = 0; i < 6; i++) {
      const angle = (i / 6) * Math.PI * 2 + this.bobOffset;
      const sparkDistance = 14 + Math.sin(this.bobOffset + i) * 2;
      const sparkX = this.x + Math.cos(angle) * sparkDistance;
      const sparkY = this.y + Math.sin(angle) * sparkDistance;
      
      ctx.fillStyle = '#ffff00';
      ctx.fillRect(sparkX - 1, sparkY - 1, 2, 2);
    }
    
    ctx.restore();
  }
}

class Swarmer {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.type = 'enemy';
    this.alive = true;
    this.points = 50;
    this.speed = 120; // Slower so player can evade them
    this.direction = 0;
  }
  
  update(deltaTime, game) {
    // Erratic movement toward player
    if (game.player && game.player.alive) {
      const dx = game.player.x - this.x;
      const dy = game.player.y - this.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      if (dist > 0) {
        this.direction = Math.atan2(dy, dx) + Math.sin(Date.now() * 0.01) * 0.5;
      }
    }
    
    this.x += Math.cos(this.direction) * this.speed * deltaTime;
    this.y += Math.sin(this.direction) * this.speed * deltaTime;
    
    // World wrap
    this.x = ((this.x % game.worldWidth) + game.worldWidth) % game.worldWidth;
  }
  
  render(ctx) {
    // Swarmer with bright energy design
    ctx.fillStyle = '#ffaadd';
    ctx.fillRect(this.x - 4, this.y - 4, 8, 8);
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(this.x - 2, this.y - 2, 4, 4);
    
    // Energy trails
    const trailColors = ['#ff66cc', '#cc44aa', '#9922aa'];
    for (let i = 0; i < 3; i++) {
      ctx.fillStyle = trailColors[i];
      const trailX = this.x - (i + 1) * 3;
      const trailY = this.y + Math.sin(Date.now() * 0.01 + i) * 2;
      ctx.fillRect(trailX - 1, trailY - 1, 2, 2);
    }
  }
}

class Mine {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.type = 'enemy';
    this.alive = true;
    this.points = 100;
    this.fallSpeed = 80; // Faster falling mines
  }
  
  update(deltaTime, game) {
    this.y += this.fallSpeed * deltaTime;
    
    // Remove if hits ground
    if (this.y > game.height - 100) {
      this.alive = false;
      game.spawnExplosion(this.x, this.y, '#ff66cc');
      // Small screen shake on mine impact
      game.addScreenShake(5, 0.3);
    }
  }
  
  render(ctx) {
    // Mine with purple/pink energy core
    ctx.fillStyle = '#cc66aa';
    ctx.beginPath();
    ctx.arc(this.x, this.y, 7, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = '#ff88cc';
    ctx.beginPath();
    ctx.arc(this.x, this.y, 5, 0, Math.PI * 2);
    ctx.fill();
    
    // Bright energy core
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.arc(this.x, this.y, 2, 0, Math.PI * 2);
    ctx.fill();
    
    // Pulsing glow
    const pulse = Math.sin(Date.now() * 0.01) * 0.3 + 0.7;
    ctx.fillStyle = `rgba(255, 136, 204, ${pulse * 0.4})`;
    ctx.beginPath();
    ctx.arc(this.x, this.y, 9, 0, Math.PI * 2);
    ctx.fill();
  }
}

class Woman {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.type = 'human';
    this.alive = true;
    this.state = 'walking'; // walking, abducted, falling, rescued
    this.animFrame = 0;
  }
  
  update(deltaTime, game) {
    if (this.state === 'walking') {
      this.animFrame += deltaTime * 5;
      // Occasional wave
      if (Math.random() < 0.01) {
        this.animFrame = 0;
      }
    } else if (this.state === 'falling') {
      this.y += 60 * deltaTime; // Much slower fall so player can catch them
      
      // Add some visual effects while falling
      if (Math.random() < 0.1) {
        // Panic particles
        game.particles.push(new Particle(
          this.x + (Math.random() - 0.5) * 10, 
          this.y + (Math.random() - 0.5) * 10, 
          '#ffff00'
        ));
      }
      
      // Check if hits ground
      const groundY = game.getTerrainHeightAt(this.x);
      if (this.y >= groundY - 15) {
        this.alive = false;
        game.spawnExplosion(this.x, this.y, '#ff0000');
        game.updateDebug('Woman lost! Impact with surface.');
        game.playSound(200, 0.5, 'sawtooth');
      }
    } else if (this.state === 'rescued') {
      // Rescued women float briefly before being teleported
      this.y -= 50 * deltaTime; // Float upward briefly
    }
  }
  
  render(ctx) {
    if (!this.alive) return;
    
    ctx.save();
    
    // Woman sprite - detailed figure with dress
    const legAnimation = Math.sin(this.animFrame * 2) * 1;
    
    // Head
    ctx.fillStyle = '#ffddaa'; // Skin tone
    ctx.fillRect(this.x - 2, this.y - 20, 4, 4);
    
    // Hair (longer for women)
    ctx.fillStyle = '#8b4513';
    ctx.fillRect(this.x - 3, this.y - 22, 6, 3); // Longer hair
    ctx.fillRect(this.x - 2, this.y - 19, 4, 1); // Hair fringe
    
    // Body/torso - different colors for different states
    let topColor = '#ff69b4'; // Pink top (more feminine)
    if (this.state === 'abducted') topColor = '#ffaa00'; // Orange when abducted
    else if (this.state === 'falling') topColor = '#ff4444'; // Red when falling
    else if (this.state === 'rescued') topColor = '#44ff44'; // Green when rescued
    
    ctx.fillStyle = topColor;
    ctx.fillRect(this.x - 2, this.y - 15, 4, 6); // Shorter torso for dress
    
    // Arms
    ctx.fillStyle = '#ffddaa';
    if (this.state === 'walking' && Math.sin(this.animFrame) > 0.5) {
      // Waving arm
      ctx.fillRect(this.x - 6, this.y - 13, 4, 1);
      ctx.fillRect(this.x - 6, this.y - 15, 1, 3);
      // Other arm
      ctx.fillRect(this.x + 2, this.y - 13, 4, 1);
    } else {
      // Normal arms
      ctx.fillRect(this.x - 5, this.y - 13, 3, 1);
      ctx.fillRect(this.x + 2, this.y - 13, 3, 1);
    }
    
    // DRESS - A-line dress shape
    let dressColor = '#9966cc'; // Purple dress
    if (this.state === 'abducted') dressColor = '#cc8800'; // Orange dress when abducted
    else if (this.state === 'falling') dressColor = '#cc4444'; // Red dress when falling
    else if (this.state === 'rescued') dressColor = '#66cc66'; // Green dress when rescued
    
    ctx.fillStyle = dressColor;
    // Dress gets wider towards the bottom (A-line shape)
    ctx.fillRect(this.x - 2, this.y - 9, 4, 3); // Upper dress
    ctx.fillRect(this.x - 3, this.y - 6, 6, 3); // Middle dress (wider)
    ctx.fillRect(this.x - 4, this.y - 3, 8, 2); // Lower dress (widest)
    
    // Dress hem detail
    ctx.fillStyle = '#663399'; // Darker purple for hem
    ctx.fillRect(this.x - 4, this.y - 2, 8, 1);
    
    // Legs (partially visible under dress)
    ctx.fillStyle = '#ffddaa'; // Skin tone for legs
    ctx.fillRect(this.x - 1, this.y - 1, 1, 2 + legAnimation * 0.5); // Left leg
    ctx.fillRect(this.x, this.y - 1, 1, 2 - legAnimation * 0.5); // Right leg
    
    // High heels/shoes
    ctx.fillStyle = '#000000'; // Black shoes
    ctx.fillRect(this.x - 2, this.y + 1, 2, 2); // Left shoe
    ctx.fillRect(this.x, this.y + 1, 2, 2); // Right shoe
    
    // Special effects for abducted state
    if (this.state === 'abducted') {
      // Distress particles
      ctx.fillStyle = '#ffff00';
      for (let i = 0; i < 3; i++) {
        const sparkX = this.x + (Math.random() - 0.5) * 8;
        const sparkY = this.y - 10 + (Math.random() - 0.5) * 8;
        ctx.fillRect(sparkX, sparkY, 1, 1);
      }
    }
    
    // Shadow on ground
    if (this.state === 'walking') {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
      ctx.fillRect(this.x - 3, this.y + 1, 6, 2);
    }
    
    ctx.restore();
  }
}

class Bullet {
  constructor(x, y, dx, dy) {
    this.x = x;
    this.y = y;
    this.dx = dx;
    this.dy = dy;
    this.type = 'bullet';
    this.speed = 600;
    this.alive = true;
  }
  
  update(deltaTime, game) {
    this.x += this.dx * this.speed * deltaTime;
    this.y += this.dy * this.speed * deltaTime;
    
    // Remove if off world
    if (this.x < -100 || this.x > game.worldWidth + 100 || 
        this.y < -50 || this.y > game.height + 50) {
      this.alive = false;
    }
  }
  
  render(ctx) {
    // Energy bolt - bright plasma
    ctx.fillStyle = '#66ccff';
    ctx.fillRect(this.x - 4, this.y - 1, 8, 2);
    
    // Bright core
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(this.x - 3, this.y - 1, 6, 2);
    
    // Energy glow trail
    ctx.fillStyle = 'rgba(102, 204, 255, 0.6)';
    ctx.fillRect(this.x - 8, this.y - 2, 4, 4);
  }
}

class Particle {
  constructor(x, y, color) {
    this.x = x;
    this.y = y;
    this.color = color;
    this.vx = (Math.random() - 0.5) * 200;
    this.vy = (Math.random() - 0.5) * 200;
    this.life = 1.0;
    this.decay = 2.0 + Math.random() * 2.0;
    this.size = 1 + Math.random() * 2; // Variable particle size
    this.glow = Math.random() > 0.5; // Some particles glow
  }
  
  update(deltaTime) {
    this.x += this.vx * deltaTime;
    this.y += this.vy * deltaTime;
    this.life -= this.decay * deltaTime;
  }
  
  render(ctx, cameraX) {
    const screenX = this.x - cameraX;
    ctx.globalAlpha = this.life;
    
    // Glowing particles have enhanced effects
    if (this.glow) {
      // Outer glow
      ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
      ctx.fillRect(screenX - this.size - 1, this.y - this.size - 1, 
                   (this.size + 1) * 2 + 2, (this.size + 1) * 2 + 2);
    }
    
    // Main particle
    ctx.fillStyle = this.color;
    ctx.fillRect(screenX - this.size, this.y - this.size, 
                 this.size * 2, this.size * 2);
    
    // Bright center for glowing particles
    if (this.glow && this.life > 0.5) {
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(screenX - Math.floor(this.size/2), this.y - Math.floor(this.size/2), 
                   Math.max(1, Math.floor(this.size)), Math.max(1, Math.floor(this.size)));
    }
    
    ctx.globalAlpha = 1;
  }
}

// Initialize game when page loads
document.addEventListener('DOMContentLoaded', () => {
  console.log('🚀 DefendHer: DOM loaded, initializing...');
  
  // Hide loading screen initially
  setTimeout(() => {
    try {
      window.defendHerGame = new DefendHerGame();
      window.defendHerGame.start();
      console.log('🚀 DefendHer: Game started successfully!');
    } catch (error) {
      console.error('🚀 DefendHer: Error starting game:', error);
      const debugDiv = document.getElementById('debug');
      if (debugDiv) {
        debugDiv.innerHTML = `
          <div style="color: #ff0000;">SYSTEM ERROR:</div>
          <div>${error.message}</div>
          <div>Check browser console for details</div>
          <div>Try refreshing the page</div>
        `;
      }
    }
  }, 100);
});

// Button event handlers
document.addEventListener('DOMContentLoaded', () => {
  const startButton = document.getElementById('startButton');
  if (startButton) {
    startButton.addEventListener('click', () => {
      if (window.defendHerGame && window.defendHerGame.gameState === 'start') {
        window.defendHerGame.startGame();
      }
    });
  }
});
</script>

<%= render 'shared/footer' %>