<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hackman - Pac-Man Clone</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #000;
            color: #ff0;
            font-family: 'Arial Black', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }
        h1 {
            color: #ff0;
            font-size: 48px;
            margin: 20px 0;
            text-shadow: 0 0 10px #ff0;
        }
        .subtitle {
            color: #fff;
            font-size: 20px;
            margin-bottom: 20px;
        }
        .stats {
            font-size: 24px;
            margin: 20px 0;
            display: flex;
            gap: 40px;
            font-family: monospace;
        }
        canvas {
            border: 4px solid #00f;
            display: block;
            margin: 20px;
            background: #000;
            image-rendering: pixelated;
        }
        button {
            padding: 15px 30px;
            font-size: 18px;
            font-weight: bold;
            background: #ff0;
            color: #000;
            border: none;
            cursor: pointer;
            margin: 10px;
        }
        button:hover {
            background: #fff;
        }
        .game-over {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 40px;
            border: 4px solid #ff0;
            text-align: center;
            display: none;
            z-index: 1000;
        }
        .game-over.show { display: block; }
    </style>
</head>
<body>
    <h1>ðŸŸ¡ HACKMAN ðŸŸ¡</h1>
    <p class="subtitle">Eat the Bitcoin!</p>

    <div class="stats">
        <span>SCORE: <span id="score">0</span></span>
        <span>LIVES: <span id="lives">3</span></span>
        <span>LEVEL: <span id="level">1</span></span>
    </div>

    <canvas id="game" width="560" height="620"></canvas>

    <div style="text-align: center;">
        <button id="startBtn">START GAME</button>
        <p style="color: #fff;">Arrow Keys: Move | Eat all dots to win!</p>
    </div>

    <div id="gameOver" class="game-over">
        <h2>GAME OVER</h2>
        <p>Score: <span id="finalScore">0</span></p>
        <button id="restartBtn">PLAY AGAIN</button>
    </div>

    <script>
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');

        const TILE = 20;
        const COLS = 28;
        const ROWS = 31;

        let gameState = 'ready';
        let score = 0;
        let lives = 3;
        let level = 1;
        let keys = {};
        let animFrame = 0;

        // Maze layout (1=wall, 0=dot, 2=power pellet, 3=empty)
        const maze = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1],
            [1,2,1,1,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,2,1],
            [1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,0,1],
            [1,0,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,0,1],
            [1,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,1],
            [1,1,1,1,1,1,0,1,1,1,1,1,3,1,1,3,1,1,1,1,1,0,1,1,1,1,1,1],
            [1,1,1,1,1,1,0,1,1,1,1,1,3,1,1,3,1,1,1,1,1,0,1,1,1,1,1,1],
            [1,1,1,1,1,1,0,1,1,3,3,3,3,3,3,3,3,3,3,1,1,0,1,1,1,1,1,1],
            [1,1,1,1,1,1,0,1,1,3,1,1,1,3,3,1,1,1,3,1,1,0,1,1,1,1,1,1],
            [1,1,1,1,1,1,0,1,1,3,1,3,3,3,3,3,3,1,3,1,1,0,1,1,1,1,1,1],
            [3,3,3,3,3,3,0,3,3,3,1,3,3,3,3,3,3,1,3,3,3,0,3,3,3,3,3,3],
            [1,1,1,1,1,1,0,1,1,3,1,3,3,3,3,3,3,1,3,1,1,0,1,1,1,1,1,1],
            [1,1,1,1,1,1,0,1,1,3,1,1,1,1,1,1,1,1,3,1,1,0,1,1,1,1,1,1],
            [1,1,1,1,1,1,0,1,1,3,3,3,3,3,3,3,3,3,3,1,1,0,1,1,1,1,1,1],
            [1,1,1,1,1,1,0,1,1,3,1,1,1,1,1,1,1,1,3,1,1,0,1,1,1,1,1,1],
            [1,1,1,1,1,1,0,1,1,3,1,1,1,1,1,1,1,1,3,1,1,0,1,1,1,1,1,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1],
            [1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1],
            [1,2,0,0,1,1,0,0,0,0,0,0,0,3,3,0,0,0,0,0,0,0,1,1,0,0,2,1],
            [1,1,1,0,1,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1],
            [1,1,1,0,1,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1],
            [1,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,1],
            [1,0,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,0,1],
            [1,0,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];

        // Player
        const player = {
            x: 14,
            y: 23,
            dir: 0, // 0=right, 1=down, 2=left, 3=up
            nextDir: 0,
            speed: 0.15,
            moving: 0,
            mouthOpen: 0,
            powered: 0
        };

        // Ghosts
        const ghosts = [
            { x: 12, y: 14, dir: 0, color: '#f00', scared: 0, name: 'Blinky' },
            { x: 14, y: 14, dir: 0, color: '#f0f', scared: 0, name: 'Pinky' },
            { x: 13, y: 15, dir: 0, color: '#0ff', scared: 0, name: 'Inky' },
            { x: 15, y: 15, dir: 0, color: '#fa0', scared: 0, name: 'Clyde' }
        ];

        let dotsLeft = 0;
        let originalMaze = maze.map(row => [...row]);

        document.addEventListener('keydown', e => {
            if (e.key === 'ArrowUp') player.nextDir = 3;
            if (e.key === 'ArrowDown') player.nextDir = 1;
            if (e.key === 'ArrowLeft') player.nextDir = 2;
            if (e.key === 'ArrowRight') player.nextDir = 0;
            e.preventDefault();
        });

        document.getElementById('startBtn').onclick = startGame;
        document.getElementById('restartBtn').onclick = restart;

        function startGame() {
            if (gameState === 'ready') {
                countDots();
                gameState = 'playing';
                gameLoop();
            }
        }

        function restart() {
            score = 0;
            lives = 3;
            level = 1;
            resetLevel();
            gameState = 'playing';
            document.getElementById('gameOver').classList.remove('show');
            updateHUD();
        }

        function resetLevel() {
            maze.forEach((row, y) => {
                row.forEach((cell, x) => {
                    maze[y][x] = originalMaze[y][x];
                });
            });
            player.x = 14;
            player.y = 23;
            player.dir = 0;
            player.powered = 0;
            ghosts.forEach((g, i) => {
                g.x = 12 + (i % 2) * 2;
                g.y = 14 + Math.floor(i / 2);
                g.scared = 0;
            });
            countDots();
        }

        function countDots() {
            dotsLeft = 0;
            maze.forEach(row => {
                row.forEach(cell => {
                    if (cell === 0 || cell === 2) dotsLeft++;
                });
            });
        }

        function gameLoop() {
            if (gameState !== 'playing') return;

            animFrame++;
            update();
            render();
            requestAnimationFrame(gameLoop);
        }

        function update() {
            // Try to change direction
            const nx = Math.round(player.x);
            const ny = Math.round(player.y);

            if (Math.abs(player.x - nx) < 0.1 && Math.abs(player.y - ny) < 0.1) {
                const [dx, dy] = getDirVector(player.nextDir);
                if (maze[ny + dy] && maze[ny + dy][nx + dx] !== 1) {
                    player.dir = player.nextDir;
                    player.x = nx;
                    player.y = ny;
                }
            }

            // Move player
            const [dx, dy] = getDirVector(player.dir);
            const newX = player.x + dx * player.speed;
            const newY = player.y + dy * player.speed;

            if (canMove(newX, newY)) {
                player.x = newX;
                player.y = newY;
                player.moving = 1;
            } else {
                player.moving = 0;
            }

            // Wrap around
            if (player.x < 0) player.x = COLS - 1;
            if (player.x >= COLS) player.x = 0;

            // Eat dots
            const px = Math.round(player.x);
            const py = Math.round(player.y);

            if (maze[py][px] === 0) {
                maze[py][px] = 3;
                score += 10;
                dotsLeft--;
                updateHUD();
            } else if (maze[py][px] === 2) {
                maze[py][px] = 3;
                score += 50;
                dotsLeft--;
                player.powered = 300; // 5 seconds
                ghosts.forEach(g => g.scared = 300);
                updateHUD();
            }

            // Power timer
            if (player.powered > 0) player.powered--;
            ghosts.forEach(g => {
                if (g.scared > 0) g.scared--;
            });

            // Move ghosts
            ghosts.forEach(ghost => {
                if (animFrame % 3 === 0) {
                    moveGhost(ghost);
                }
            });

            // Check collisions
            ghosts.forEach(ghost => {
                const dist = Math.abs(player.x - ghost.x) + Math.abs(player.y - ghost.y);
                if (dist < 0.5) {
                    if (ghost.scared > 0) {
                        score += 200;
                        ghost.x = 14;
                        ghost.y = 14;
                        ghost.scared = 0;
                        updateHUD();
                    } else {
                        loseLife();
                    }
                }
            });

            // Check win
            if (dotsLeft === 0) {
                level++;
                updateHUD();
                resetLevel();
            }

            // Mouth animation
            player.mouthOpen = (Math.floor(animFrame / 5) % 2) && player.moving;
        }

        function getDirVector(dir) {
            return [[1, 0], [0, 1], [-1, 0], [0, -1]][dir];
        }

        function canMove(x, y) {
            const ix = Math.round(x);
            const iy = Math.round(y);
            return maze[iy] && maze[iy][ix] !== 1;
        }

        function moveGhost(ghost) {
            const dirs = [0, 1, 2, 3];
            const validDirs = dirs.filter(d => {
                const [dx, dy] = getDirVector(d);
                return canMove(ghost.x + dx * 0.5, ghost.y + dy * 0.5);
            });

            if (validDirs.length > 0) {
                if (ghost.scared > 0) {
                    // Run away from player
                    ghost.dir = validDirs[Math.floor(Math.random() * validDirs.length)];
                } else {
                    // Chase player (simple AI)
                    const target = validDirs.sort((a, b) => {
                        const [ax, ay] = getDirVector(a);
                        const [bx, by] = getDirVector(b);
                        const aDist = Math.abs(player.x - (ghost.x + ax)) + Math.abs(player.y - (ghost.y + ay));
                        const bDist = Math.abs(player.x - (ghost.x + bx)) + Math.abs(player.y - (ghost.y + by));
                        return aDist - bDist;
                    });
                    ghost.dir = target[0];
                }
            }

            const [dx, dy] = getDirVector(ghost.dir);
            ghost.x += dx * 0.08;
            ghost.y += dy * 0.08;

            // Wrap
            if (ghost.x < 0) ghost.x = COLS - 1;
            if (ghost.x >= COLS) ghost.x = 0;
        }

        function loseLife() {
            lives--;
            updateHUD();

            if (lives <= 0) {
                gameOver();
            } else {
                player.x = 14;
                player.y = 23;
                player.dir = 0;
                player.powered = 0;
                ghosts.forEach((g, i) => {
                    g.x = 12 + (i % 2) * 2;
                    g.y = 14 + Math.floor(i / 2);
                    g.scared = 0;
                });
            }
        }

        function gameOver() {
            gameState = 'gameover';
            document.getElementById('finalScore').textContent = score;
            document.getElementById('gameOver').classList.add('show');
        }

        function updateHUD() {
            document.getElementById('score').textContent = score;
            document.getElementById('lives').textContent = lives;
            document.getElementById('level').textContent = level;
        }

        function render() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw maze
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    const cell = maze[y][x];

                    if (cell === 1) {
                        ctx.fillStyle = '#00f';
                        ctx.fillRect(x * TILE, y * TILE, TILE, TILE);
                    } else if (cell === 0) {
                        ctx.fillStyle = '#fff';
                        ctx.fillRect(x * TILE + 8, y * TILE + 8, 4, 4);
                    } else if (cell === 2) {
                        ctx.fillStyle = '#fff';
                        ctx.fillRect(x * TILE + 5, y * TILE + 5, 10, 10);
                    }
                }
            }

            // Draw player
            ctx.fillStyle = '#ff0';
            ctx.beginPath();
            const px = player.x * TILE + TILE / 2;
            const py = player.y * TILE + TILE / 2;
            const mouthAngle = player.mouthOpen ? 0.3 : 0.05;
            const startAngle = player.dir * Math.PI / 2 + mouthAngle;
            const endAngle = player.dir * Math.PI / 2 + Math.PI * 2 - mouthAngle;
            ctx.arc(px, py, TILE / 2 - 2, startAngle, endAngle);
            ctx.lineTo(px, py);
            ctx.fill();

            // Draw ghosts
            ghosts.forEach(ghost => {
                ctx.fillStyle = ghost.scared > 0 ? '#00f' : ghost.color;
                const gx = ghost.x * TILE;
                const gy = ghost.y * TILE;

                // Body
                ctx.beginPath();
                ctx.arc(gx + TILE / 2, gy + TILE / 2, TILE / 2 - 2, Math.PI, 0);
                ctx.lineTo(gx + TILE - 2, gy + TILE - 2);
                ctx.lineTo(gx + TILE / 2 + 4, gy + TILE / 2 + 6);
                ctx.lineTo(gx + TILE / 2, gy + TILE - 2);
                ctx.lineTo(gx + TILE / 2 - 4, gy + TILE / 2 + 6);
                ctx.lineTo(gx + 2, gy + TILE - 2);
                ctx.closePath();
                ctx.fill();

                // Eyes
                ctx.fillStyle = '#fff';
                ctx.fillRect(gx + 4, gy + 6, 5, 5);
                ctx.fillRect(gx + 11, gy + 6, 5, 5);
                ctx.fillStyle = '#000';
                ctx.fillRect(gx + 6, gy + 8, 2, 2);
                ctx.fillRect(gx + 13, gy + 8, 2, 2);
            });
        }

        updateHUD();
    </script>
</body>
</html>